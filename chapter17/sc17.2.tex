\subchapter{Metoda księgowania}

\exercise %17.2-1
Operację wykonywania kopii bezpieczeństwa nazwiemy \proc{Backup}.
W~naszym rozwiązaniu metodą księgowania przypiszemy koszt zamortyzowany równy 2 dla operacji \proc{Push} i~\proc{Pop} oraz 0 dla operacji \proc{Backup}.

Wykażemy, że używając takich kosztów, jesteśmy w~stanie spełnić nierówność (17.1) w~dowolnym ciągu $n$ operacji.
Możemy wyobrazić sobie, że za każde wstawienie elementu na stos i~każde usunięcie elementu ze stosu płacimy 2 zł, czyli 1 zł za rzeczywisty koszt samej operacji plus 1 zł kredytu na poczet przyszłych operacji.
W~momencie gdy wywołana zostanie procedura \proc{Backup}, na stosie będzie znajdować się co najwyżej $k$ elementów, wstawionych tam przez co najwyżej $k$ wywołań \proc{Push}, więc rzeczywisty koszt wywołania \proc{Backup} będzie wynosił co najwyżej $k$.
Po wywołaniu dokładnie $k$ operacji \proc{Push} i~\proc{Pop} łączna wartość kredytu na stosie wynosi dokładnie $k$ zł, zatem kredyt ten wystarczy na pokrycie kosztu operacji \proc{Backup}.

Zamortyzowanym kosztem każdej operacji jest więc $O(1)$, co oznacza, że łączny koszt ciągu $n$ operacji można oszacować przez $O(n)$.

\exercise %17.2-2
Każdej operacji przypiszemy koszt zamortyzowany $\widehat{c_i}=3$.
Z~\refExercise{17.1-3} wiemy, że $\sum_{i=1}^nc_i<3n$, dlatego kredyt w~żadnym momencie nie jest ujemny, bo
\[
	\sum_{i=1}^n\widehat{c_i} = 3n > \sum_{i=1}^nc_i.
\]
Koszt zamortyzowany każdej operacji można więc oszacować przez $\Theta(1)$.

\exercise %17.2-3
W~naszej implementacji licznika z~wektorem bitów $A$ powiążemy atrybut \id{highest}, w~którym będziemy pamiętać najwyższy rząd bitu ustawionego na 1 aktualnie w~liczniku.
Dokładniej, $\attrib{A}{highest}=k$, gdzie $k\ge0$, jeśli wartość licznika znajduje się w~przedziale $[2^k,2^{k+1})$, oraz $\attrib{A}{highest}=\const{nil}$, jeśli wartością licznika jest 0.
Procedura \proc{Increment} powinna dodatkowo tuż przed zakończeniem uaktualnić wartość pola \attrib{A}{highest}.
Pseudokod procedury zerującej licznik przedstawiono poniżej.
\begin{codebox}
\Procname{$\proc{Reset}(A)$}
\li	\For $i\gets0$ \To \attrib{A}{highest}
\li		\Do $A[i]\gets0$
		\End
\li	$\attrib{A}{highest}\gets\const{nil}$
\end{codebox}

Podobnie jak w~analizie kosztu zamortyzowanego przeprowadzonej w~Podręczniku, za każde ustawienie bitu na 1 w~procedurze \proc{Increment} zapłacimy 1 zł, po czym ,,położymy'' na tym bicie 1 zł jako kredyt.
Dodatkowo, jeśli zwiększy się wartość pola \attrib{A}{highest}, to kolejne 1 zł ,,położymy'' na nowej jedynce najwyższego rzędu.
Ten dodatkowy kredyt wykorzystany będzie do spłacenia kosztu zerowania licznika procedurą \proc{Reset}.

Możemy zatem powiązać koszt zamortyzowany równy 3 z~każdym wywołaniem \proc{Increment} oraz zerowy koszt zamortyzowany z~każdym wywołaniem \proc{Reset}.
Wnioskujemy stąd, że dowolny ciąg $n$ operacji zwiększenia i~zerowania licznika można wykonać w~czasie $O(n)$.
