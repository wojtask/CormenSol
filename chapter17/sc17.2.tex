\subchapter{Metoda księgowania}

\exercise %17.2-1
Operację wykonywania kopii bezpieczeństwa będziemy nazywać \proc{Backup}.
W~naszym rozwiązaniu metodą księgowania operacjom przypiszemy następujące koszty zamortyzowane:
\begin{flushleft}
	\begin{tabular}{lr}
		\proc{Push} & 2, \\
		\proc{Pop} & 1, \\
		\proc{Backup} & 0.
	\end{tabular}
\end{flushleft}
Wykażemy, że przy takich wartościach jesteśmy w~stanie spełnić nierówność (17.1) dla dowolnego ciągu $n$ operacji.
Możemy wyobrazić sobie, że za każde wstawienie elementu na stos płacimy 2~zł, czyli 1~zł za rzeczywisty koszt samej operacji plus 1~zł kredytu na poczet przyszłych operacji.
Po wywołaniu dokładnie $k$ operacji \proc{Push} i~\proc{Pop} łączna wartość kredytu na stosie wynosi dokładnie $k$~zł, co wystarcza na zapłacenie za wykonanie kopii bezpieczeństwa, gdy operacja \proc{Backup} jest wywoływana na stosie o~co najwyżej $k$ elementach.

Zamortyzowanym kosztem każdej operacji jest więc $O(1)$, co oznacza, że łączny koszt ciągu $n$ operacji można oszacować przez $O(n)$.

\exercise %17.2-2
Każdej operacji przypiszemy koszt zamortyzowany $\widehat{c_i}=3$.
Z~\refExercise{17.1-3} wiemy, że $\sum_{i=1}^nc_i<3n$, dlatego kredyt w~żadnym momencie nie jest ujemny, bo
\[
	\sum_{i=1}^n\widehat{c_i} = 3n > \sum_{i=1}^nc_i.
\]
Koszt zamortyzowany każdej operacji jest więc rzędu $O(1)$.

\exercise %17.2-3
W~naszej implementacji licznika, z~wektorem bitów $A$ powiążemy atrybut \id{highest}, w~którym będziemy pamiętać pozycję najbardziej znaczącej jedynki w~tym liczniku.
Dokładniej, $\attrib{A}{highest}=k$, gdzie $k\ge0$, jeśli wartość licznika znajduje się w~przedziale $[2^k,2^{k+1})$.
Jeśli wartością licznika jest 0, to przyjmiemy $\attrib{A}{highest}=-1$.
Poniżej przedstawiono pseudokod wersji procedury \proc{Increment}, która dodatkowo aktualizuje wartość pola \attrib{A}{highest} oraz procedury zerującej licznik.
\begin{codebox}
\Procname{$\proc{Increment}'(A)$}
\li	$i\gets0$
\li	\While $i<\attrib{A}{length}$ i~$A[i]=1$
\li		\Do $A[i]\gets0$
\li			$i\gets i+1$
		\End
\li	\If $i<\attrib{A}{length}$
\li		\Then $A[i]\gets1$
\li			\If $i>\attrib{A}{highest}$
\li				\Then $\attrib{A}{highest}\gets i$ \label{li:increment'-highest-increased}
				\End
\li		\Else $\attrib{A}{highest}\gets-1$
		\End
\end{codebox}
\begin{codebox}
\Procname{$\proc{Reset}(A)$}
\li	\For $i\gets0$ \To \attrib{A}{highest}
\li		\Do $A[i]\gets0$
		\End
\li	$\attrib{A}{highest}\gets-1$
\end{codebox}

Podobnie jak w~analizie kosztu zamortyzowanego przeprowadzonej w~Podręczniku, za każde ustawienie bitu na 1 w~procedurze $\proc{Increment}'$ płacimy 1~zł, po czym ,,kładziemy'' na tym bicie 1~zł jako kredyt.
Dodatkowo, jeśli zwiększy się wartość pola \attrib{A}{highest} (linia \ref{li:increment'-highest-increased}), to kolejne 1~zł ,,kładziemy'' na nowej jedynce najwyższego rzędu.
Ten dodatkowy kredyt wykorzystany będzie do spłacenia kosztu zerowania licznika procedurą \proc{Reset}.
Możemy zatem powiązać koszt zamortyzowany równy 3 z~każdym wywołaniem $\proc{Increment}'$ oraz zerowy koszt zamortyzowany z~każdym wywołaniem \proc{Reset}.
Wnioskujemy stąd, że dowolny ciąg $n$ operacji inkrementacji i~zerowania licznika można wykonać w~czasie $O(n)$.
