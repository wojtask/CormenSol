\subchapter{Metoda księgowania}

\exercise %17.2-1
Operację wykonywania kopii bezpieczeństwa będziemy nazywać \proc{Backup}.
W~naszym rozwiązaniu metodą księgowania operacjom przypiszemy następujące koszty zamortyzowane:
\begin{flushleft}
	\begin{tabular}{lr}
		\proc{Push} & 2, \\
		\proc{Pop} & 1, \\
		\proc{Backup} & 0.
	\end{tabular}
\end{flushleft}
Wykażemy, że przy takich wartościach jesteśmy w~stanie spełnić nierówność (17.1) dla dowolnego ciągu $n$ operacji.
Możemy wyobrazić sobie, że za każde wstawienie elementu na stos płacimy 2~zł, czyli 1~zł za rzeczywisty koszt samej operacji plus 1~zł kredytu na poczet przyszłych operacji.
Po wywołaniu dokładnie $k$ operacji \proc{Push} i~\proc{Pop} łączna wartość kredytu na stosie wynosi dokładnie $k$~zł, co wystarcza na zapłacenie za wykonanie kopii bezpieczeństwa, gdy operacja \proc{Backup} jest wywoływana na stosie o~co najwyżej $k$ elementach.

Zamortyzowanym kosztem każdej operacji jest więc $O(1)$, co oznacza, że łączny koszt ciągu $n$ operacji można oszacować przez $O(n)$.

\exercise %17.2-2
Każdej operacji przypiszemy koszt zamortyzowany $\widehat{c_i}=3$.
Z~\refExercise{17.1-3} wiemy, że $\sum_{i=1}^nc_i<3n$, dlatego kredyt w~żadnym momencie nie jest ujemny, bo
\[
	\sum_{i=1}^n\widehat{c_i} = 3n > \sum_{i=1}^nc_i.
\]
Koszt zamortyzowany każdej operacji jest więc rzędu $O(1)$.

\exercise %17.2-3
W~naszej implementacji licznika z~wektorem bitów $A$ powiążemy atrybut \id{highest}, w~którym będziemy pamiętać najwyższy rząd bitu ustawionego na 1 aktualnie w~liczniku.
Dokładniej, $\attrib{A}{highest}=k$, gdzie $k\ge0$, jeśli wartość licznika znajduje się w~przedziale $[2^k,2^{k+1})$, oraz $\attrib{A}{highest}=\const{nil}$, jeśli wartością licznika jest 0.
Procedura \proc{Increment} powinna dodatkowo tuż przed zakończeniem uaktualnić wartość pola \attrib{A}{highest}.
Pseudokod procedury zerującej licznik przedstawiono poniżej.
\begin{codebox}
\Procname{$\proc{Reset}(A)$}
\li	\For $i\gets0$ \To \attrib{A}{highest}
\li		\Do $A[i]\gets0$
		\End
\li	$\attrib{A}{highest}\gets\const{nil}$
\end{codebox}

Podobnie jak w~analizie kosztu zamortyzowanego przeprowadzonej w~Podręczniku, za każde ustawienie bitu na 1 w~procedurze \proc{Increment} zapłacimy 1~zł, po czym ,,położymy'' na tym bicie 1~zł jako kredyt.
Dodatkowo, jeśli zwiększy się wartość pola \attrib{A}{highest}, to kolejne 1~zł ,,położymy'' na nowej jedynce najwyższego rzędu.
Ten dodatkowy kredyt wykorzystany będzie do spłacenia kosztu zerowania licznika procedurą \proc{Reset}.

Możemy zatem powiązać koszt zamortyzowany równy 3 z~każdym wywołaniem \proc{Increment} oraz zerowy koszt zamortyzowany z~każdym wywołaniem \proc{Reset}.
Wnioskujemy stąd, że dowolny ciąg $n$ operacji zwiększenia i~zerowania licznika można wykonać w~czasie $O(n)$.
