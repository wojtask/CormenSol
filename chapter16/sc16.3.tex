\subchapter{Kody Huffmana}

\exercise %16.3-1
Drzewo $T$, które nie jest regularne, zawiera co najmniej jeden węzeł $x$ o~stopniu 1.
Jeśli węzeł ten zostanie ,,wycięty'' z~$T$, to głębokość każdego potomka węzła $x$ zmniejszy się o~1 i~powstałe w~ten sposób drzewo będzie mieć koszt niższy od $T$.
Można ten koszt obniżać, pozbywając się w~ten sposób wszystkich węzłów stopnia 1 i~uzyskując drzewo regularne.

\exercise %16.3-2
Jeden z~optymalnych kodów Huffmana dla podanego zbioru liter i~ich częstości ilustruje rys.\ \ref{fig:16.3-2}.
\begin{figure}[!ht]
	\centering \input{fig16.3-2}
	\caption{{\sffamily\bfseries(a)} Optymalny kod Huffmana dla liter \texttt{a}, \texttt{b}, \dots, \texttt{h} o~częstościach będących początkowymi liczbami Fibonacciego.
{\sffamily\bfseries(b)} Drzewo odpowiadające optymalnemu temu kodowi uzyskane w~wyniku działania procedury \proc{Huffman}.} \label{fig:16.3-2}
\end{figure}

Zastanówmy się, jak może wyglądać optymalny kod Huffmana dla $n$ liter o~częstościach będących początkowymi liczbami Fibonacciego.
Przyjrzyjmy się wartości \attrib{z}{f} obliczanej w~algorytmie \proc{Huffman} w~linii 7.
Nietrudno zauważyć, że w~\singledash{$i$}{tej} iteracji pętli \kw{for} jest to suma najmniejszych $i+1$ częstości liter, czyli suma $i+1$ pierwszych liczb Fibonacciego:
\[
	\attrib{z}{f} = \sum_{k=1}^{i+1}F_k = F_{i+3}-1.
\]
Gdy $i>1$, to $F_{i+2}<\attrib{z}{f}<F_{i+3}$, dlatego wartość \attrib{z}{f} w~iteracji $i+1$ jest drugą najmniejszą w~kolejce $Q$ i~węzeł ten zostaje wybrany na prawego syna kolejnego węzła $z$.
W~pierwszej iteracji zachodzi $\attrib{z}{f}=2=F_3$, ale implementacja kolejki priorytetowej także wtedy doprowadzi do opisanego powiązania węzłów.
Zbudowane drzewo będzie mieć wysokość $n-1$, przy czym lewy syn każdego jego węzła wewnętrznego będzie liściem.
W~otrzymanym kodzie Huffmana, literze o~częstości $F_k$, gdzie $3\le k\le n$, przypisane zostanie słowo kodowe postaci
\[
	\underbrace{11\cdots1}_{n-k}0.
\]
Litery o~częstościach $F_1=F_2=1$ są nierozróżnialne z~punktu widzenia tego problemu, więc następujące dwa słowa kodowe:
\[
	\underbrace{11\cdots1}_{n-2}0 \quad\text{oraz}\quad \underbrace{11\cdots1}_{n-1}
\]
mogą być przypisane do tych liter w~dowolnej kolejności.

\exercise %16.3-3
\exercise %16.3-4
Niech $C=\{c_1,c_2,\dots,c_n\}$ będzie zbiorem znaków o~częstościach $f(c_1)\ge f(c_2)\ge\dots\ge f(c_n)$.
Niech $T$ będzie drzewem odpowiadającym optymalnemu kodowi Huffmana dla znaków ze zbioru $C$.
Przypomnijmy, że głębokość liścia reprezentującego znak $c\in C$ w~drzewie $T$ jest długością słowa kodowego przypisanego do znaku $c$.

Udowodnimy żądaną własność nie-wprost, poprzez założenie, że istnieją takie $1\le i<j\le n$, że $d_T(c_i)>d_T(c_j)$ i~doprowadzenie do sprzeczności.
Suma kosztów wprowadzana przez znaki $c_i$ i~$c_j$ do kosztu drzewa $B(T)$ wynosi $f(c_i)d_T(c_i)+f(c_j)d_T(c_j)$.
Porównajmy ją z~sumą kosztów tych znaków w~przypadku, gdyby zostały one zamienione miejscami w~drzewie $T$.
Różnica
\[
	f(c_i)d_T(c_i)+f(c_j)d_T(c_j)-\bigl(f(c_i)d_T(c_j)+f(c_j)d_T(c_i)\bigr) = \bigl(f(c_i)-f(c_j)\bigr)\bigl(d_T(c_i)-d_T(c_j)\bigr)
\]
jest dodatnia, na podstawie przyjętych założeń.
A~zatem drzewo powstałe z~$T$ poprzez zamianę miejscami znaków $c_i$ i~$c_j$ ma niższy koszt niż drzewo $T$, dlatego $T$ nie może reprezentować optymalnego kodowania.
Wynika stąd, że w~optymalnym drzewie każde dwa znaki o~niemalejących częstościach zajmują nierosnące głębokości, a~więc ich słowa kodowe także mają nierosnące długości.

\exercise %16.3-5
Drzewo $T$ reprezentujące optymalne kodowanie zbioru $C$ zawiera $n$ liści i~$n-1$ węzłów wewnętrznych.
Jego strukturę możemy zakodować, przechodząc je w~porządku preorder i~zamiast wypisywać klucz węzła, odnotowywać 0, jeśli jest to węzeł wewnętrzny, albo 1, jeśli jest on liściem.
Ponieważ drzewo $T$ jest regularne, to opisane kodowanie jest jednoznaczne i~składa się z~$2n-1$ bitów.
Należy jeszcze uzupełnić je o~informacje, któremu liściowi w~$T$ odpowiada który znak z~$C$.
Zauważmy, że do zapisania każdego znaku z~$C$ w~postaci binarnej, przy pomocy zwykłego kodu o~stałej długości, potrzeba $\lceil\lg n\rceil$ bitów.
Można więc użyć łącznie $n\lceil\lg n\rceil$ bitów do zapisania ciągu wszystkich znaków w~kolejności wyznaczonej przez liście w~kodowaniu drzewa $T$.

\exercise %16.3-6
\exercise %16.3-7
\exercise %16.3-8
