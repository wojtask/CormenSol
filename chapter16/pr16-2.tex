\problem{Szeregowanie o~minimalnym średnim czasie wykonania zadań} %16-2

\subproblem %16-2(a)
Rozważmy dowolne uszeregowanie zadań stanowiące rozwiązanie przedstawionego problemu.
Załóżmy, że dla pewnych zadań $a_i$, $a_j$ w~tym uszeregowaniu, tuż po zakończeniu wykonywania zadania $a_i$ w~chwili $c_i$ komputer przerywa pracę na jakiś czas -- czyli kolejne zadanie $a_j$ rozpoczęte zostaje w~chwili $b_j$ późniejszej niż $c_i$.
Jednakże przez wyeliminowanie tej przerwy moglibyśmy przesunąć rozpoczęcie wykonywania wszystkich zadań występujących po $a_i$ o~$c_i-b_j$ jednostek czasu wcześniej.
W~rezultacie wykonywanie tych zadań zakończyłoby się wcześniej o~tyle samo jednostek czasu i~otrzymane w~ten sposób uszeregowanie miałoby niższy średni czas zakończenia.
Wnioskujemy stąd, że w~optymalnym uporządkowaniu zadania wykonywane są bezpośrednio po sobie.

Przyjmijmy teraz, że w~uszeregowaniu nie ma przerw między zadaniami i~że istnieją zadania $a_i$, $a_j$, dla których $p_i>p_j$ oraz $a_i$ wykonywane jest bezpośrednio przed $a_j$.
Suma ich czasów zakończenia wnoszona do średniego czasu zakończenia rozważanego uszeregowania wynosi $C=c_i+c_j$.
Oznaczmy przez $c_i'$, $c_j'$, odpowiednio, czasy zakończenia zadań $a_i$, $a_j$, gdyby zostały one zamienione miejscami w~tym uporządkowaniu.
Z~założenia $c_i'=c_j$ oraz $c_j'<c_i$, a~więc suma nowych czasów zakończenia wynosi $C'=c_i'+c_j'<c_j+c_i=C$, podczas gdy czasy zakończenia pozostałych zadań nie ulegają zmianie.
Wynika stąd, że w~optymalnym uszeregowaniu zadania powinny występować według ich czasów wykonywania, od najkrótszego do najdłuższego.

Na podstawie powyższej analizy wynika, że w~celu rozwiązania postawionego problemu wystarczy posortować zadania ze zbioru $S$ według ich czasów wykonywania, co daje algorytm działający w~czasie $O(n\lg n)$.

\subproblem %16-2(b)
Każde zadanie ze zbioru wejściowego będziemy reprezentować jako element o~wadze początkowo równej liczbie jednostek czasu potrzebnej do jego wykonania.
Elementy reprezentujące zadania gotowe do wykonania w~danej chwili na podstawie czasów pojawienia się, przechowywane będą w~zbiorze dynamicznym $S$.
W~danej chwili $b$ do zbioru $S$ zostaną dodane zadania, które właśnie stały się gotowe do wykonania, czyli takie, dla których $r_i=b$.
W~razie wyboru zadania $a_i$ do uszeregowania w~chwili $b$, waga tego zadania w~zbiorze $S$ zostanie zmniejszona o~1, co reprezentuje wykonanie fragmentu tego zadania w~chwili $b$ o~długości jednostki czasu.
Jeśli waga danego zadania osiąga 0, to jest ono usuwane z~$S$.

W~celu minimalizacji średniego czasu zakończenia zadań, postępujemy według podobnego schematu jak w~punkcie (a).
Ponieważ aktualna waga elementu w~$S$ oznacza pozostały czas wymagany do wykonania tego zadania, to w~danym momencie optymalnym wyborem jest to zadanie ze zbioru $S$, które ma minimalną wagę (o~ile $S$ nie jest zbiorem pustym).
Zaimplementowanie zbioru dynamicznego $S$ w~postaci kolejki priorytetowej typu min pozwala na szybkie pobieranie elementu o~minimalnej wadze oraz na dekrementowanie wag elementów.
W~trakcie działania algorytmu każde zadanie zostanie wstawione do $S$, a~po wyzerowaniu jego wagi usunięte.
Łącznie wykonanych będzie $P=\sum_{i=1}^np_i$ dekrementacji wag elementów i~tyle samo wyszukiwań elementu o~najmniejszej wadze w~$S$.
Zbiór $S$ może zawierać maksymalnie $n$ elementów, zatem algorytm wykona co najwyżej $O(P\lg n)$ operacji.
