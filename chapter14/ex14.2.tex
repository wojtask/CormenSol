\subchapter{Jak wzbogacać strukturę danych}

\exercise %14.2-1
Aby efektywnie wykonywać podane operacje, wzbogacimy każdy węzeł wewnętrzny $x$ drzewa statystyk pozycyjnych $T$ o~2 nowe pola:
\begin{itemize}
	\item \attrib{x}{prev} -- wskaźnik na poprzednika węzła $x$ albo \attrib{T}{nil}, jeśli poprzednik nie istnieje,
	\item \attrib{x}{next} -- wskaźnik na następnika węzła $x$ albo \attrib{T}{nil}, jeśli następnik nie istnieje.
\end{itemize}
Pola te dodamy także do wartownika \attrib{T}{nil}, dla którego \id{prev} będzie pokazywało na węzeł o~największym kluczu w~drzewie, a~\id{next} -- na węzeł o~najmniejszym kluczu w~drzewie.
W~pustym drzewie $T$ będzie $\attribb{T}{nil}{prev}=\attribb{T}{nil}{next}=\attrib{T}{nil}$.
Innymi słowy, węzły wewnętrzne drzewa będą tworzyć uporządkowaną listę cykliczną z~wartownikiem \attrib{T}{nil}.

Tw.\ 14.1 nie stosuje się do nowych pól, bo ich wartości mogą zależeć nie tylko od pól synów danego węzła -- zarówno następnik, jak i~poprzednik węzła może nie znajdować się w~jego poddrzewach.
Pokażemy jednak, że nadal możliwe jest efektywne zaimplementowanie operacji wstawiania i~usuwania, które aktualizują wartości tych pól.

Zauważmy, że rotacje nie modyfikują pól \id{prev} i~\id{next}, ponieważ nie naruszają porządku inorder węzłów drzewa.
Po wstawieniu do drzewa nowego węzła $z$ można ustawić atrybut \attrib{z}{prev} na wartość zwróconą przez wywołanie oryginalnej wersji operacji \proc{Predecessor}, a~atrybut \id{next} -- na wynik oryginalnej wersji operacji \proc{Successor}.
Należy jeszcze uaktualnić \attribb{z}{prev}{next} i~\attribb{z}{next}{prev} na $z$.
Odpowiednie zdefiniowanie nowych pól w~wartowniku sprawia, że aktualizacja ta ma sens również wtedy, gdy \attrib{z}{prev} lub \attrib{z}{next} są \attrib{T}{nil}.
Nowe pola należy zaktualizować także w~operacji \proc{Delete}.
Tuż przed zakończeniem procedury dla faktycznie usuniętego węzła $y$ wystarczy ustawić \attribb{y}{prev}{next} oraz \attribb{y}{next}{prev} na $y$.
Widać więc, że dodatkowe wywołania nie powiększają asymptotycznego czasu działania operacji \proc{Insert} i~\proc{Delete}.

Dzięki wykorzystaniu nowo dodanych atrybutów operacje na zbiorach dynamicznych można zaimplementować w~czasie $O(1)$, aby zwracały następujące wartości:
\begin{itemize}
	\item $\proc{Minimum}(T)$: \attribb{T}{nil}{next},
	\item $\proc{Maximum}(T)$: \attribb{T}{nil}{prev},
	\item $\proc{Predecessor}(T,x)$: \attrib{x}{prev},
	\item $\proc{Successor}(T,x)$: \attrib{x}{next}.
\end{itemize}

\exercise %14.2-2
Jeśli czarną wysokość wewnętrznego węzła $x$ w~drzewie czerwono-czarnym $T$ przechowamy w~polu \attrib{x}{bh}, a~ponadto zdefiniujemy $\attribb{T}{nil}{bh}=0$, to zachodzi następująca zależność:
\[
	\attrib{x}{bh} = \begin{cases}
		\attribb{x}{left}{bh}, & \text{jeśli $\attribb{x}{left}{color}=\const{red}$}, \\
		\attribb{x}{left}{bh}+1, & \text{jeśli $\attribb{x}{left}{color}=\const{black}$}.
	\end{cases}
\]
A~zatem na mocy tw.\ 14.1 mamy, że złożoność asymptotyczna operacji słownikowych na tak wzbogaconym drzewie czerwono-czarnym nie ulegnie zmianie.

\exercise %14.2-3
Nie można tego zrobić przy zachowaniu efektywnych czasów działania operacji na drzewie, ponieważ głębokość węzła zależy od głębokości jego ojca.
Gdy zmienia się głębokość węzła $x$, to zmieniają się także głębokości wszystkich potomków $x$.
A~zatem aktualizacja głębokości korzenia drzewa o~$n$ węzłach niesie za sobą konieczność aktualizacji pozostałych $n-1$ węzłów i~operacje wstawiania i~usuwania wymagają wtedy czasu $\Omega(n\lg n)$.

\exercise %14.2-4
Posługując się rys.\ 13.2 z~Podręcznika, oznaczmy przez $r_\alpha$, $r_\beta$, $r_\gamma$ korzenie poddrzew, odpowiednio, $\alpha$, $\beta$, $\gamma$.
Ponieważ operacja $\otimes$ jest łączna, to mamy
\begin{align*}
	\attrib{x}{f} &= \attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes\attrib{r_\beta}{f}\otimes\attrib{y}{a}\otimes\attrib{r_\gamma}{f}, \\
	\attrib{y}{f} &= \phantom{\attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes{}}\attrib{r_\beta}{f}\otimes\attrib{y}{a}\otimes\attrib{r_\gamma}{f}.
\end{align*}
Rotacje nie zmieniają porządku inorder węzłów w~żadnym z~poddrzew $\alpha$, $\beta$ i~$\gamma$, dlatego po przeprowadzeniu lewej rotacji wartości pola $f$ wynoszą
\begin{align*}
	\attrib{x}{f} &= \attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes\attrib{r_\beta}{f}, \\
	\attrib{y}{f} &= \attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes\attrib{r_\beta}{f}\otimes\attrib{y}{a}\otimes\attrib{r_\gamma}{f}
\end{align*}
i~mogą zostać obliczone w~czasie $O(1)$.
Rozumowanie w~przypadku prawej rotacji przeprowadza się analogicznie.

W~drzewie czerwono-czarnym $T$ zdefiniujmy teraz dla każdego węzła pole $a$ przyjmujące wartość 0 dla liści drzewa (reprezentowanych przez \attrib{T}{nil}) oraz 1 dla jego węzłów wewnętrznych.
Jeśli operacją $\otimes$ będzie zwykłe dodawanie, to wartość \attrib{x}{f} zdefiniowana jak w~treści zadania, będzie rozmiarem poddrzewa o~korzeniu w~$x$, czyli pole $f$ będzie identyczne z~polem \id{size} z~drzew statystyk pozycyjnych.
Dzięki powyżej przedstawionej argumentacji pole \id{size} może być aktualizowane w~czasie $O(1)$ po każdym wykonaniu rotacji w~drzewie $T$.

\exercise %14.2-5
Następujący algorytm stanowi implementację nowej operacji.
Przyjmuje on dodatkowo jako parametr drzewo $T$ potrzebne do odwołania się do \attrib{T}{nil} i~wypisuje szukane klucze w~porządku niemalejącym.
\begin{codebox}
\Procname{$\proc{RB-Enumerate}(T,x,a,b)$}
\li \If $x\ne\attrib{T}{nil}$
\li		\Then \If $\attrib{x}{key}>a$
\li				\Then $\proc{RB-Enumerate}(T,\attrib{x}{left},a,b)$ \label{li:rb-enumerate-recurse-left-subtree}
				\End
\li			\If $a\le\attrib{x}{key}\le b$
\li				\Then wypisz \attrib{x}{key} \label{li:rb-enumerate-print}
				\End
\li			\If $\attrib{x}{key}<b$
\li				\Then $\proc{RB-Enumerate}(T,\attrib{x}{right},a,b)$ \label{li:rb-enumerate-recurse-right-subtree}
				\End
		\End
\end{codebox}

Udowodnimy poprawność tego algorytmu.
Klucz węzła $x$ wypisywany jest w~linii \ref{li:rb-enumerate-print} tylko wtedy, gdy $a\le\attrib{x}{key}\le b$.
Jeśli $\attrib{x}{key}<a$, to wiadomo, że każdy klucz w~lewym poddrzewie $x$ również jest mniejszy od $a$, dlatego procedura nie schodzi rekurencyjnie do lewego poddrzewa.
Podobnie w~przypadku, gdy $\attrib{x}{key}>b$.
Wykorzystując indukcję, można więc dowieść, że wywołanie $\proc{RB-Enumerate}(T,\attrib{T}{root},a,b)$ wypisze każdy klucz z~drzewa $T$ leżący w~przedziale $[a,b]$ i~nie wypisze kluczy spoza tego przedziału.

Załóżmy, że procedura \proc{RB-Enumerate} została wywołana dla $x=\attrib{T}{root}$, gdzie $T$ jest drzewem o~$n$ węzłach wewnętrznych, i~oszacujmy, ile węzłów jest odwiedzanych w~trakcie tego wywołania.
Oznaczmy przez $S$ zbiór tych węzłów drzewa $T$, których klucze leżą w~przedziale $[a,b]$.
Na podstawie poprzedniego paragrafu odwiedzony zostanie każdy z~$m$ węzłów ze zbioru $S$.
Zauważmy, że jeśli $x\in S$, to procedura może zostać wywołana rekurencyjnie zarówno dla lewego poddrzewa $x$, jak i~jego prawego poddrzewa.
Gdy z~kolei $x\not\in S$ oraz $x\ne\attrib{T}{nil}$, to $\attrib{x}{key}<a$ albo $\attrib{x}{key}>b$.
W~pierwszej sytuacji wiersz \ref{li:rb-enumerate-recurse-left-subtree} nie zostanie wykonany, a~w~drugiej -- wiersz \ref{li:rb-enumerate-recurse-right-subtree}.
Wynika stąd, że jeśli $x\not\in S$ i~$x\ne\attrib{T}{nil}$, to procedura wywoła się rekurencyjnie co najwyżej raz.
Zaobserwujmy, że dla każdych $x$, $y\in S$, jeśli węzeł $y$ znajduje się w~lewym poddrzewie $x$, to wszystkie węzły z~prawego poddrzewa $y$ także należą do $S$, i~symetrycznie w~przypadku, gdy węzeł $y$ jest w~prawym poddrzewie $x$.
Wynika stąd, że gdy algorytm osiągnie najwyżej położony w~$T$ węzeł $z\in S$, to na każdym następnym poziomie rekursji algorytm wywołany będzie dla co najwyżej jednego węzła spoza $S$.
Innymi słowy, na każdym poziomie drzewa głębiej od $z$ odwiedzane są w~kolejnych wywołaniach rekurencyjnych co najwyżej dwa węzły spoza $S$, jeden w~lewym poddrzewie $z$, a~drugi w~prawym poddrzewie $z$.
Z~tego powodu sumaryczna liczba węzłów spoza $S$ odwiedzanych w~algorytmie jest ograniczona od góry przez $2h=O(\lg n)$.
Sumaryczna liczba sprawdzonych węzłów wynosi zatem $O(m+\lg n)$.
Nie jest to oszacowanie dokładne, jak sugeruje treść zadania, ponieważ rekurencja w~optymistycznym przypadku nie zejdzie do liści drzewa i~algorytm może potrzebować tylko czasu rzędu $\Omega(m)$.
