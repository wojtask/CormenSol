\subchapter{Dynamiczne statystyki pozycyjne}

\exercise %14.1-1
Algorytm rozpoczyna działanie od $i=10$ oraz ze zmienną $x$ pokazującą na korzeń drzewa $T$.
Ranga klucza 26 wyznaczona w~linii 1 wynosi 13, więc algorytm zostaje wywołany rekurencyjnie dla lewego poddrzewa, czyli dla węzła o~kluczu 17.
W~wywołaniu tym obliczona ranga klucza 17 wynosi 8.
Szukany element jest więc $10-8=2$ (drugim) największym elementem w~prawym poddrzewie aktualnego węzła.
Po wywołaniu rekurencyjnym zmienna $x$ wskazuje na jeden z~węzłów o~kluczu 21, ten na głębokości 2, a~$i=2$.
Ranga tego klucza zostaje wyznaczona na 3, dlatego szukany klucz należy do lewego poddrzewa.
W~kolejnym wywołaniu mamy $x$ wskazujące na węzeł o~kluczu 19 oraz $i=2$.
Tym razem jednak lewe poddrzewo jest puste, ale zdefiniowanie \attribb{T}{nil}{size} jako 0 pozwala obliczyć rangę obecnego elementu jako 1.
Algorytm wywoływany jest więc rekurencyjnie jeszcze raz w~celu znalezienia $2-1=1$ (pierwszego) elementu w~prawym poddrzewie.
Po wyznaczeniu rangi i~porównaniu z~wartością zmiennej $i=1$ zwracany jest wskaźnik do węzła o~kluczu 20.

\exercise %14.1-2
Na początku działania procedury zmienna $r$ zostaje zainicjalizowana na 1, a~$y$ początkowo wskazuje węzeł $x$.
W~tabeli \ref{tab:14.1-2} zamieszczono wartości \attrib{y}{key} oraz $r$ na początku każdej iteracji pętli \kw{while}.
Wynikiem zwracanym w~wywołaniu procedury jest 16.
\begin{table}[!ht]
	\centering
		\begin{tabular}{rrr}
			iteracja & \attrib{y}{key} & $r$ \\ \hline
			1 & 35 & 1 \\
			2 & 38 & 1 \\
			3 & 30 & 3 \\
			4 & 41 & 3 \\
			5 & 26 & 16
		\end{tabular}
		\caption{Przebieg działania pętli \kw{while} w~procedurze \proc{OS-Rank} wywołanej dla drzewa $T$ z~rys.\ 14.1 z~Podręcznika oraz $x$ takiego, że $\attrib{x}{key}=35$.} \label{tab:14.1-2}
\end{table}

\exercise %14.1-3
Iteracyjna wersja \proc{OS-Select} wykorzystuje pętlę \kw{while}, w~której symulowana jest rekurencja z~wersji rekurencyjnej przez odpowiednie zaktualizowanie zmiennych $x$ oraz $i$.
Gdy $x$ wskazuje na węzeł o~szukanym kluczu, pętla jest przerywana poprzez zwrócenie $x$ jako wyniku procedury.
\begin{codebox}
\Procname{$\proc{Iterative-OS-Select}(x,i)$}
\li	\While \const{true}
\li		\Do $r\gets\attribb{x}{left}{size}+1$
\li			\If $i=r$
\li				\Then \Return $x$
				\End
\li			\If $i<r$
\li				\Then $x\gets\attrib{x}{left}$
\li				\Else $x\gets\attrib{x}{right}$
\li					$i\gets i-r$
				\End
		\End
\end{codebox}

\exercise %14.1-4
W~naszej implementacji procedura przyjmować będzie jako parametr węzeł $x$ drzewa $T$ zamiast samego drzewa.
Pozwoli to wywoływać procedurę rekurencyjnie w~celu znalezienia rangi klucza w~poddrzewach $T$.
\begin{codebox}
\Procname{$\proc{OS-Key-Rank}(x,k)$}
\li	$r=\attribb{x}{left}{size}+1$
\li	\If $k=\attrib{x}{key}$
\li		\Then \Return $r$ \label{li:os-key-rank-key-found}
		\End
\li	\If $k<\attrib{x}{key}$
\li		\Then \Return $\proc{OS-Key-Rank}(\attrib{x}{left},k)$
\li		\Else \Return $\proc{OS-Key-Rank}(\attrib{x}{right},k)+r$
		\End
\end{codebox}
Po wyznaczeniu rangi $r$ klucza \attrib{x}{key}, jeśli jest on elementem, którego rangi szukamy, to w~wierszu \ref{li:os-key-rank-key-found} nastąpi zwrócenie $r$.
W~przeciwnym przypadku procedura wywołuje się rekurencyjne dla lewego poddrzewa $x$ albo prawego poddrzewa $x$, w~zależności od tego, w~którym z~nich szukany klucz się znajduje na podstawie własności drzewa wyszukiwań binarnych.
W~przeciwnym przypadku, jeśli $k<\attrib{x}{key}$, to ranga klucza $k$ w~poddrzewie o~korzeniu $x$ jest równa jego randze w~poddrzewie o~korzeniu \attrib{x}{left}.
Gdy natomiast $k>\attrib{x}{key}$, to ranga $k$ w~poddrzewie o~korzeniu $x$ jest o~$r$ większa od jego rangi w~poddrzewie o~korzeniu \attrib{x}{right}.

Aby wyznaczyć rangę klucza $k$ w~drzewie statystyk pozycyjnych $T$ zawierającego parami różne klucze, należy wywołać $\proc{OS-Key-Rank}(\attrib{T}{root},k)$.

\exercise %14.1-5
Załóżmy, że ranga klucza \attrib{x}{key} wynosi $r$.
Wystarczy zauważyć, że \singledash{$i$}{ty} następnik węzła $x$ jest węzłem z~kluczem o~randze $r+i$.
Najpierw wyznaczamy więc $r$ w~czasie $O(\lg n)$, wywołując $\proc{OS-Rank}(T,x)$, a~następnie, również w~czasie $O(\lg n)$, szukamy w~$T$ elementu o~randze $r+i$, czyli wykonujemy $\proc{OS-Select}(\attrib{T}{root},r+i)$.

\exercise %14.1-6
\exercise %14.1-7
\exercise %14.1-8
