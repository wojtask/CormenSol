\subchapter{Dynamiczne statystyki pozycyjne}

\exercise %14.1-1
Algorytm rozpoczyna działanie z~parametrami $x$ pokazującym na korzeń drzewa $T$ oraz $i=10$.
Ranga klucza 26 wyznaczona w~linii 1 wynosi 13, więc algorytm zostaje wywołany rekurencyjnie dla lewego poddrzewa, czyli dla węzła o~kluczu 17.
W~wywołaniu tym obliczona ranga klucza 17 wynosi 8.
Szukany element jest więc $10-8=2$ (drugim) największym elementem w~prawym poddrzewie aktualnego węzła.
Algorytm zostaje więc wywołany rekurencyjnie dla $x$ wskazującego na jeden z~węzłów o~kluczu 21, ten na głębokości 2, oraz $i=2$.
Ranga tego klucza zostaje wyznaczona na 3, dlatego szukany klucz należy do lewego poddrzewa.
W~kolejnym wywołaniu $x$ wskazuje na węzeł o~kluczu 19, a~$i=2$.
Tym razem jednak lewe poddrzewo jest puste, ale zdefiniowanie \attribb{T}{nil}{size} jako 0 pozwala obliczyć rangę obecnego elementu jako 1.
Algorytm wywoływany jest więc rekurencyjnie jeszcze raz w~celu znalezienia $2-1=1$ (pierwszego) elementu w~prawym poddrzewie.
Po wyznaczeniu rangi i~porównaniu z~wartością zmiennej $i=1$ zwracany jest wskaźnik do węzła o~kluczu 20.

\exercise %14.1-2
Na początku działania procedury zmienna $r$ zostaje zainicjalizowana na 1, a~$y$ początkowo wskazuje węzeł $x$.
W~tabeli \ref{tab:14.1-2} zamieszczono wartości \attrib{y}{key} oraz $r$ na początku każdej iteracji pętli \kw{while}.
Wynikiem zwracanym w~wywołaniu procedury jest 16.
\begin{table}[!ht]
	\centering
		\begin{tabular}{rrr}
			iteracja & \attrib{y}{key} & $r$ \\ \hline
			1 & 35 & 1 \\
			2 & 38 & 1 \\
			3 & 30 & 3 \\
			4 & 41 & 3 \\
			5 & 26 & 16
		\end{tabular}
		\caption{Przebieg działania pętli \kw{while} w~procedurze \proc{OS-Rank} wywołanej dla drzewa $T$ z~rys.\ 14.1 z~Podręcznika oraz $x$ takiego, że $\attrib{x}{key}=35$.} \label{tab:14.1-2}
\end{table}

\exercise %14.1-3
Iteracyjna wersja \proc{OS-Select} wykorzystuje pętlę \kw{while}, w~której symulowana jest rekurencja z~wersji rekurencyjnej przez odpowiednie zaktualizowanie zmiennych $x$ oraz $i$.
Gdy $x$ wskazuje na węzeł o~szukanym kluczu, pętla jest przerywana poprzez zwrócenie $x$ jako wyniku procedury.
\begin{codebox}
\Procname{$\proc{Iterative-OS-Select}(x,i)$}
\li	\While \const{true}
\li		\Do $r\gets\attribb{x}{left}{size}+1$
\li			\If $i=r$
\li				\Then \Return $x$
				\End
\li			\If $i<r$
\li				\Then $x\gets\attrib{x}{left}$
\li				\Else $x\gets\attrib{x}{right}$
\li					$i\gets i-r$
				\End
		\End
\end{codebox}

\exercise %14.1-4
W~naszej implementacji procedura przyjmować będzie jako parametr węzeł $x$ drzewa $T$ zamiast samego drzewa.
Pozwoli to wywoływać procedurę rekurencyjnie w~celu znalezienia rangi klucza w~poddrzewach $T$.
\begin{codebox}
\Procname{$\proc{OS-Key-Rank}(x,k)$}
\li	$r=\attribb{x}{left}{size}+1$
\li	\If $k=\attrib{x}{key}$
\li		\Then \Return $r$ \label{li:os-key-rank-key-found}
		\End
\li	\If $k<\attrib{x}{key}$
\li		\Then \Return $\proc{OS-Key-Rank}(\attrib{x}{left},k)$
\li		\Else \Return $\proc{OS-Key-Rank}(\attrib{x}{right},k)+r$
		\End
\end{codebox}
Po wyznaczeniu rangi $r$ klucza \attrib{x}{key}, jeśli jest on elementem, którego rangi szukamy, to w~wierszu \ref{li:os-key-rank-key-found} nastąpi zwrócenie $r$.
W~przeciwnym przypadku procedura wywołuje się rekurencyjne dla lewego poddrzewa $x$ albo prawego poddrzewa $x$, w~zależności od tego, w~którym z~nich szukany klucz się znajduje na podstawie własności drzewa wyszukiwań binarnych.
W~przeciwnym przypadku, jeśli $k<\attrib{x}{key}$, to ranga klucza $k$ w~poddrzewie o~korzeniu $x$ jest równa jego randze w~poddrzewie o~korzeniu \attrib{x}{left}.
Gdy natomiast $k>\attrib{x}{key}$, to ranga $k$ w~poddrzewie o~korzeniu $x$ jest o~$r$ większa od jego rangi w~poddrzewie o~korzeniu \attrib{x}{right}.

Aby wyznaczyć rangę klucza $k$ w~drzewie statystyk pozycyjnych $T$ zawierającego parami różne klucze, należy wywołać $\proc{OS-Key-Rank}(\attrib{T}{root},k)$.

\exercise %14.1-5
Załóżmy, że ranga klucza \attrib{x}{key} wynosi $r$.
Wystarczy zauważyć, że \singledash{$i$}{ty} następnik węzła $x$ jest węzłem z~kluczem o~randze $r+i$.
Najpierw wyznaczamy więc $r$ w~czasie $O(\lg n)$, wywołując $\proc{OS-Rank}(T,x)$, a~następnie, również w~czasie $O(\lg n)$, szukamy w~$T$ elementu o~randze $r+i$, czyli wykonujemy $\proc{OS-Select}(\attrib{T}{root},r+i)$.

\exercise %14.1-6
Pamiętajmy, że rotacje nie zmieniają uszeregowania inorder kluczy w~drzewie, dlatego wykonanie rotacji nie zmienia ich rang.

Podczas wstawiania nowego węzła $z$ do drzewa statystyk pozycyjnych szukamy dla niego odpowiedniego miejsca na ścieżce w~dół od korzenia drzewa.
Dla każdego węzła $x$ na tej ścieżce, jeśli $\attrib{z}{key}<\attrib{x}{key}$, to węzeł $z$ jest umieszczany w~lewym poddrzewie $x$ i~ranga każdego węzła $y$ z~prawego poddrzewa węzła $x$ rośnie o~1, bo $z$ będzie poprzedzał każde takie $y$ w~porządku inorder po zakończeniu wstawiania.
Jeśli z~kolei $z$ ląduje w~prawym poddrzewie $x$, to rangi węzłów lewego poddrzewa $x$ nie zmieniają się.

W~przypadku usuwania jeśli $x$ jest dowolnym węzłem na ścieżce od efektywnie usuniętego węzła w~górę drzewa aż do korzenia, to zmianie, a~dokładniej zmniejszeniu o~1, ulegają rangi każdego węzła $y$ należącego do prawego poddrzewa węzła $x$.

Widać więc, że utrzymywanie w~każdym węźle drzewa jego rangi powoduje, że operacje wstawiania i~usuwania wymagają czasu $O(n)$, gdzie $n$ jest liczbą węzłów w~drzewie.

\exercise %14.1-7
Niech $A=[1\twodots n]$ będzie tablicą zawierającą liczby parami różne.
Oznaczmy przez $r_i$ rangę elementu $A[i]$ w~podtablicy $A[1\twodots i]$.
Dla każdego $i=1$, 2, \dots, $n$ element $A[i]$ jest zatem \singledash{$r_i$}{tym} najmniejszym elementem w~podtablicy $A[1\twodots i]$, dlatego z~innymi elementami w~tej podtablicy tworzy $i-r_i$ inwersji.
Sumaryczna liczba inwersji w~tablicy $A$ jest więc równa $\sum_{i=1}^n(i-r_i)$.

Rangi elementów tablicy $A$ możemy wyznaczyć, wstawiając do drzewa statystyk pozycyjnych kolejno, $A[1]$, $A[2]$, \dots, $A[n]$.
Tuż po wstawieniu elementu $A[i]$ jego ranga w~aktualnym drzewie wynosi $r_i$, którą to wartość otrzymujemy za pomocą algorytmu \proc{OS-Rank}.
Wstawienie dowolnego elementu tablicy $A$ do drzewa oraz obliczenie jego rangi wymaga czasu $O(\lg n)$, dlatego inwersje w~$A$ możemy policzyć w~czasie $O(n\lg n)$.

\exercise %14.1-8
Ponumerujmy końce cięciw liczbami od 1 do $n$ w~taki sposób, aby dwa różne punkty miały ten sam numer wtedy i~tylko wtedy, gdy są końcami tej samej cięciwy.
Niech $\sigma$ będzie ciągiem wszystkich tych etykiet czytanych wzdłuż okręgu w~ustalonym kierunku.
Zauważmy, że $\sigma$ składa się z~$2n$ wyrazów, a~każdy z~nich pojawia się dokładnie 2 razy.
Cięciwa oznaczona jako $i$ przecina się z~cięciwą oznaczoną jako $j$ wtedy i~tylko wtedy, gdy dokładnie jeden egzemplarz $i$ znajduje się w~$\sigma$ pomiędzy dwoma egzemplarzami $j$.

Algorytm będzie przeglądał ciąg $\sigma$ od lewej do prawej.
Będzie on zapamiętywał, które z~etykiet pojawiły się dotychczas dokładnie raz w~trakcie tego przeglądania.
W~momencie gdy pewna liczba $i$ pojawia się drugi raz, policzy, ile liczb różnych od $i$ pojawiło się dokładnie raz po pierwszym wystąpieniu $i$.
Wartość ta oznacza liczbę cięciw przecinających się z~cięciwą o~numerze $i$.

W~algorytmie użyjemy dwóch tablic do zapamiętania cięciw.
W~tablicy $E[1\twodots n]$ w~komórce $E[i]$ będziemy zapisywać pozycję pierwszego wystąpienia $i$ w~ciągu $\sigma$, a~w~wektorze bitowym $\id{seen}[1\twodots n]$ wartość \const{true} na \singledash{$i$}{tej} pozycji będzie oznaczać, że $i$ zostało już napotkane w~trakcie przeglądania ciągu $\sigma$.
Potrzebny będzie nam też zbiór dynamiczny $S$ przechowujący wartości z~tablicy $E$ dla liczb, które pojawiły się dokładnie raz.
Zbiór $S$ będziemy reprezentować, używając w~tym celu drzewa statystyk pozycyjnych, które pozwoli na generowanie odpowiedzi na pytania ,,ile elementów zbioru $S$ jest większych od $x$'' w~czasie $O(\lg n)$.
\begin{codebox}
\Procname{$\proc{Intersecting-Chords}(\sigma)$}
\li	\For $k=1$ \To $2n$
\li		\Do $\id{seen}[k]=\const{false}$
		\End
\li	$\id{intersections}\gets0$
\li	$S\gets\emptyset$
\li	\For $k=1$ \To $2n$
\li		\Do $j\gets\sigma_k$
\li			\If $\id{seen}[j]=\const{false}$
\li				\Then $\id{seen}[j]\gets\const{true}$
\li					$E[j]=k$
\li					$S\gets S\cup\{k\}$
\li				\Else $\id{intersections}\gets\id{intersections}+\bigl|\{s\in S:s>E[j]\}\bigr|$
\li					$S\gets S\setminus\{E[j]\}$
				\End
		\End
\li	\Return \id{intersections}
\end{codebox}

Zastanówmy się nad poprawnością przedstawionego algorytmu.
Dla każdej etykiety $i$ niech $\sigma_{s_i}=\sigma_{t_i}=i$, gdzie $s_i<t_i$ są pozycjami końców cięciwy $i$ w~ciągu $\sigma$.
Rozważmy cięciwy $i$ oraz $j$, dla których $s_i<s_j$.
Jeśli cięciwa $i$ i~$j$ przecinają się, to $s_j<t_i<t_j$ i~przecięcie to zostanie policzone dokładnie raz -- wtedy, gdy przetwarzany będzie \singledash{$t_i$}{ty} wyraz ciągu $\sigma$.
W~przeciwnym przypadku $t_j<t_i$, więc tego (nieistniejącego) przecięcia nie policzymy.

Aby otrzymać czas działania algorytmu, zauważmy, że każda etykieta jest wstawiana do $S$ dokładnie raz i~co najwyżej jedno zapytanie z~wiersza 11 zostaje wykonane w~celu policzenia elementów ze zbioru $S$ większych od tej etykiety.
Ponieważ obydwie te operacje działają w~czasie $O(\lg n)$, to stąd czasem działania algorytmu jest $O(n\lg n)$.
