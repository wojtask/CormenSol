\subchapter{Jak wzbogacać strukturę danych}

\exercise %14.2-1
Aby efektywnie wykonywać podane operacje, wzbogacimy każdy węzeł $x$ drzewa statystyk pozycyjnych $T$ o~4 nowe pola:
\begin{itemize}
	\item \attrib{x}{min} -- wskaźnik na węzeł o~najmniejszym kluczu w~poddrzewie o~korzeniu w~$x$,
	\item \attrib{x}{max} -- wskaźnik na węzeł o~największym kluczu w~poddrzewie o~korzeniu w~$x$,
	\item \attrib{x}{pred} -- wskaźnik na poprzednika węzła $x$ (lub \attrib{T}{nil} jeśli poprzednik nie istnieje),
	\item \attrib{x}{succ} -- wskaźnik na następnika węzła $x$ (lub \attrib{T}{nil} jeśli następnik nie istnieje).
\end{itemize}
Przyjmujemy, że wartością każdego z~tych pól dla \attrib{T}{nil} jest \attrib{T}{nil}.

Wartości pól \id{min} oraz \id{max} każdego wewnętrznego węzła $x$ można wyznaczyć na podstawie jedynie wartości tych pól w~synach węzła $x$.
Niech
\[
	\mu_x = \min(\attribbb{x}{left}{min}{key},\attrib{x}{key},\attribbb{x}{right}{min}{key}).
\]
Wówczas:
\[
	\attrib{x}{min} = \begin{cases}
		\attribb{x}{left}{min}, & \text{jeśli $\mu_x=\attribbb{x}{left}{min}{key}$,} \\
		x, & \text{jeśli $\mu_x=\attrib{x}{key}$,} \\
		\attribb{x}{right}{min}, & \text{jeśli $\mu_x=\attribbb{x}{right}{min}{key}$.}
	\end{cases}	
\]
Analogicznie można wyznaczyć wartość pola \attrib{x}{max}.
Zatem zgodnie z~tw.\ 14.1 można zachować poprawne wartości tych pól podczas wstawiania i~usuwania, nie zwiększając asymptotycznej złożoności tych operacji.

Jednakże w~przypadku pól \id{pred} i~\id{succ} nie można zastosować tw.\ 14.1, bo wartości tych pól mogą zależeć nie tylko od pól synów danego węzła -- zarówno następnik, jak i~poprzednik węzła może znajdować się na wyższym poziomie drzewa.
Pokażemy jednak, że nadal możliwe jest efektywne zaimplementowanie operacji wstawiania i~usuwania, które aktualizują wartości tych pól.

Zauważmy najpierw, że rotacje nie pociągają za sobą konieczności modyfikacji pól \id{pred} i~\id{succ}.
Jest tak dlatego, że porządek inorder węzłów w~drzewie nie zostaje zmieniony przez rotacje, więc nie ma zmian w~poprzednikach i~następnikach.
Po wstawieniu nowego węzła do drzewa wystarczy więc nadać jego atrybutowi \id{pred} wartość zwróconą przez wywołanie oryginalnej wersji operacji \proc{Predecessor}, a~atrybutowi \id{succ} -- oryginalnej wersji operacji \proc{Successor}.
Nowe pola można zaktualizować także w~operacji \proc{Delete}.
Wystarczy tuż przed usunięciem węzła odnaleźć jego poprzednik $p$ i~następnik $s$ poprzez wywołanie zwykłych wersji operacji \proc{Predecessor} i~\proc{Successor}.
Następnie tuż po usunięciu węzła wystarczy ustawić \attrib{p}{succ} na $s$ (o~ile $p\ne\attrib{T}{nil}$), a~\attrib{s}{pred} na $p$ (o~ile $s\ne\attrib{T}{nil}$).
Widać więc, że dodatkowe wywołania nie powiększają czasu działania operacji \proc{Insert} i~\proc{Delete}.

Dzięki wykorzystaniu nowo dodanych atrybutów wywołania $\proc{Minimum}(T)$, $\proc{Maximum}(T)$, $\proc{Predecessor}(T,x)$ i~$\proc{Successor}(T,x)$ można zaimplementować w~czasie $O(1)$ tak, aby zwracały, odpowiednio, \attribb{T}{root}{min}, \attribb{T}{root}{max}, \attrib{x}{pred} i~\attrib{x}{succ}.

\exercise %14.2-2
Jeśli czarną wysokość wewnętrznego węzła $x$ w~drzewie czerwono-czarnym $T$ przechowamy w~polu \attrib{x}{bh}, a~ponadto zdefiniujemy $\attribb{T}{nil}{bh}=0$, to zachodzi następująca zależność:
\[
	\attrib{x}{bh} = \begin{cases}
		\attribb{x}{left}{bh}, & \text{jeśli $\attribb{x}{left}{color}=\const{red}$}, \\
		\attribb{x}{left}{bh}+1, & \text{jeśli $\attribb{x}{left}{color}=\const{black}$}.
	\end{cases}
\]
A~zatem na mocy tw.\ 14.1 mamy, że złożoność asymptotyczna operacji słownikowych na tak wzbogaconym drzewie czerwono-czarnym nie ulegnie zmianie.

\exercise %14.2-3
Nie można tego zrobić przy zachowaniu efektywnych czasów działania operacji na drzewie, ponieważ głębokość węzła zależy od głębokości jego ojca.
Gdy zmienia się głębokość węzła $x$, to zmieniają się także głębokości wszystkich potomków $x$.
A~zatem aktualizacja głębokości korzenia drzewa niesie za sobą konieczność aktualizacji pozostałych $n-1$ węzłów drzewa i~operacje wstawiania i~usuwania wymagają wtedy czasu $\Omega(n\lg n)$.

\exercise %14.2-4
Posługując się rys.\ 13.2 z~Podręcznika, oznaczmy przez $r_\alpha$, $r_\beta$, $r_\gamma$ korzenie poddrzew, odpowiednio, $\alpha$, $\beta$, $\gamma$.
Ponieważ operacja $\otimes$ jest łączna, to mamy
\begin{align*}
	\attrib{x}{f} &= \attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes\attrib{r_\beta}{f}\otimes\attrib{y}{a}\otimes\attrib{r_\gamma}{f}, \\
	\attrib{y}{f} &= \phantom{\attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes{}}\attrib{r_\beta}{f}\otimes\attrib{y}{a}\otimes\attrib{r_\gamma}{f}.
\end{align*}
Rotacje nie zmieniają porządku inorder węzłów w~żadnym z~poddrzew $\alpha$, $\beta$ i~$\gamma$, dlatego po przeprowadzeniu lewej rotacji wartości pola $f$ wynoszą
\begin{align*}
	\attrib{x}{f} &= \attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes\attrib{r_\beta}{f}, \\
	\attrib{y}{f} &= \attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes\attrib{r_\beta}{f}\otimes\attrib{y}{a}\otimes\attrib{r_\gamma}{f}
\end{align*}
i~mogą zostać obliczone w~czasie $O(1)$.
Rozumowanie w~przypadku prawej rotacji przeprowadza się analogicznie.

W~drzewie czerwono-czarnym $T$ zdefiniujmy teraz dla każdego węzła pole $a$ przyjmujące wartość 0 dla liści drzewa (reprezentowanych przez \attrib{T}{nil}) oraz 1 dla jego węzłów wewnętrznych.
Jeśli operacją $\otimes$ będzie zwykłe dodawanie, to wartość \attrib{x}{f} będzie rozmiarem poddrzewa o~korzeniu w~$x$, czyli pole $f$ będzie identyczne z~polem \id{size} z~drzew statystyk pozycyjnych.
Dzięki powyżej przedstawionej argumentacji pole \id{size} może być aktualizowane w~czasie $O(1)$ po każdym wykonaniu rotacji w~drzewie $T$.

\exercise %14.2-5
Do zaimplementowania tej operacji potrzebna nam będzie pomocnicza procedura wyszukująca w~drzewie czerwono-czarnym węzeł o~najmniejszym kluczu większym lub równym podanej wartości.
\begin{codebox}
\Procname{$\proc{RB-Search-Upper-Bound}(T,x,k)$}
\li	\If $z\gets\attrib{T}{nil}$
\li	\While \const{true}
\li		\Do \If $x=\attrib{T}{nil}$
\li				\Then \Return $y$ \label{li:rb-search-upper-bound-return-z}
				\End
\li			\If $\attrib{x}{key}=k$
\li				\Then \Return $x$ \label{li:rb-search-upper-bound-return-x}
				\End
\li			\If $k<\attrib{x}{key}$
\li				\Then $z\gets x$
\li					$x\gets\attrib{x}{left}$
\li				\Else $x\gets\attrib{x}{right}$
				\End
		\End
\end{codebox}
Jest to modyfikacja procedury \proc{Iterative-RB-Search}, która z~kolei jest wersją procedury \proc{Iterative-Tree-Search} przystosowaną do drzew czerwono-czarnych.
W~drzewie $T$ wyszukiwany jest węzeł o~kluczu $k$ i~jeśli istnieje, to zostaje zwrócony w~linii \ref{li:rb-search-upper-bound-return-x}.
W~przeciwnym przypadku w~wierszu \ref{li:rb-search-upper-bound-return-z} następuje zwrócenie następnika węzła o~kluczu $k$, gdyby znajdował się on w~drzewie $T$.
Zmienna $z$ w~kolejnych iteracjach pętli \kw{while} wskazuje na węzeł będący przodkiem aktualnie testowanego węzła $x$ znajdującego się w~lewym poddrzewie $z$, albo na \attrib{T}{nil}, jeżeli węzeł taki nie istnieje w~$T$.
Poza utrzymywaniem odpowiedniej wartości zmiennej $z$, procedura wykonuje te same działania, co \proc{Iterative-RB-Search}, a~zatem działa w~czasie $O(\lg n)$ dla drzewa $T$ o~$n$ węzłach.

Rozważymy także modyfikację operacji następnika, \proc{RB-Subtree-Successor}, która przyjmuje dodatkowy, trzeci parametr $z$ i~znajduje następnik węzła $x$ w~poddrzewie o~korzeniu $z$.
Jeśli taki węzeł nie istnieje w~tym poddrzewie, to zwracane jest \attrib{T}{nil}.
Modyfikacja polega na dodaniu następującego fragmentu między wiersz 2 i~3 w~\proc{RB-Successor}, co nie zwiększa czasu działania tej procedury:
\begin{codebox}
\zi	\If $x=\proc{RB-Maximum}(T,z)$
\zi		\Then \Return \attrib{T}{nil}
		\End
\end{codebox}

Następujący algorytm stanowi implementację szukanej operacji.
Przyjmuje on dodatkowo jako parametr drzewo $T$ potrzebne do odwołania się do \attrib{T}{nil} i~wypisuje szukane klucze w~porządku niemalejącym.
\begin{codebox}
\Procname{$\proc{RB-Enumerate}(T,x,a,b)$}
\li $z\gets\proc{RB-Search-Upper-Bound}(T,x,a)$ \label{li:rb-enumerate-initial-node}
\li	\While $z\ne\attrib{T}{nil}$ i~$a\le\attrib{z}{key}\le b$
\li		\Do wypisz \attrib{z}{key}
\li			$z\gets\proc{RB-Subtree-Successor}(T,x,z)$ \label{li:rb-enumerate-next-node}
		\End
\end{codebox}
Zmienna $z$ jest inicjalizowana na węzeł o~kluczu $k\ge a$ z~poddrzewa o~korzeniu w~$x$.
Jeśli węzeł taki nie istnieje (bo poddrzewo $x$ zawiera klucze mniejsze od $a$), to $z=\attrib{T}{nil}$ i~procedura kończy działanie.
W~przeciwnym przypadku następuje seria wywołań operacji następnika $y$ w~wierszu \ref{li:rb-enumerate-next-node}, aż do wyczerpania węzłów w~poddrzewie $x$ albo odnalezienia węzła o~kluczu przekraczającym $b$.

Wywołanie z~linii \ref{li:rb-enumerate-initial-node} zajmuje czas $O(\lg n)$.
Na mocy \refExercise{12.2-8} niezależnie od tego, od którego węzła rozpoczniemy, seria $m$ wywołań operacji następnika w~drzewie o~wysokości $h=O(\lg n)$ potrzebuje czasu $O(m+\lg n)$, co stanowi czas działania przedstawionego algorytmu.
