\subchapter{Jak wzbogacać strukturę danych}

\exercise %14.2-1
Aby efektywnie wykonywać podane operacje, wzbogacimy każdy węzeł drzewa statystyk pozycyjnych o~4 pola wskaźnikowe:
\begin{itemize}
	\item \id{min} -- wskaźnik na węzeł o~najmniejszym kluczu w~drzewie,
	\item \id{max} -- wskaźnik na węzeł o~największym kluczu w~drzewie,
	\item \id{pred} -- wskaźnik na poprzednika danego węzła oraz
	\item \id{succ} -- wskaźnik na następnika danego węzła.
\end{itemize}
W~szczególności, jeśli węzeł $x$ ma najmniejszy klucz w~drzewie $T$, to $\attrib{x}{min}=x$ i~$\attrib{x}{pred}=\attrib{T}{nil}$.

Wartość każdego nowego pola można wyznaczyć na podstawie jedynie wartości tych pól w~synach danego węzła:
\begin{itemize}
	\item $\attrib{x}{min}=\attribb{x}{left}{min}=\attribb{x}{right}{min}$;
	\item $\attrib{x}{max}=\attribb{x}{left}{max}=\attribb{x}{right}{max}$;
	\item $\attrib{x}{pred}=\attribb{x}{left}{max}$;
	\item $\attrib{x}{succ}=\attribb{x}{right}{min}$.
\end{itemize}
Zatem zgodnie z~tw.\ 14.1 można zachować poprawne wartości tych pól podczas wstawiania i~usuwania, nie zwiększając asymptotycznej złożoności tych operacji.
Operacje $\proc{Minimum}(T)$ i~$\proc{Maximum}(T)$ polegają na zwróceniu, odpowiednio, \attribb{T}{root}{min} i~\attribb{T}{root}{max}, natomiast operacje $\proc{Predecessor}(T,x)$ i~$\proc{Successor}(T,x)$ polegają na zwróceniu, odpowiednio, \attrib{x}{pred} i~\attrib{x}{succ}.

\exercise %14.2-2
Jeśli czarną wysokość wewnętrznego węzła $x$ w~drzewie czerwono-czarnym $T$ przechowamy w~polu \attrib{x}{bh}, a~ponadto zdefiniujemy $\attribb{T}{nil}{bh}=0$, to zachodzi następująca zależność:
\[
	\attrib{x}{bh} = \begin{cases}
		\attribb{x}{left}{bh}, & \text{jeśli $\attribb{x}{left}{color}=\const{red}$}, \\
		\attribb{x}{left}{bh}+1, & \text{jeśli $\attribb{x}{left}{color}=\const{black}$}.
	\end{cases}
\]
A~zatem na mocy tw.\ 14.1 mamy, że złożoność asymptotyczna operacji na tak wzbogaconym drzewie czerwono-czarnym nie ulegnie zmianie.

\exercise %14.2-3
Nie można tego zrobić przy zachowaniu efektywnych czasów działania operacji na drzewie, ponieważ głębokość węzła zależy od głębokości jego ojca.
Gdy zmienia się głębokość węzła $x$, to zmieniają się także głębokości wszystkich potomków $x$.
A~zatem aktualizacja głębokości korzenia drzewa niesie za sobą konieczność aktualizacji pozostałych $n-1$ węzłów drzewa i~operacje wstawiania i~usuwania działają wtedy w~czasie $O(n\lg n)$.

\exercise %14.2-4
Posługując się rys.\ 13.2 z~Podręcznika, oznaczmy przez $r_\alpha$, $r_\beta$, $r_\gamma$ korzenie poddrzew, odpowiednio, $\alpha$, $\beta$, $\gamma$.
Ponieważ operacja $\otimes$ jest łączna, to mamy
\begin{align*}
	\attrib{x}{f} &= \attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes\attrib{r_\beta}{f}\otimes\attrib{y}{a}\otimes\attrib{r_\gamma}{f}, \\
	\attrib{y}{f} &= \phantom{\attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes{}}\attrib{r_\beta}{f}\otimes\attrib{y}{a}\otimes\attrib{r_\gamma}{f}.
\end{align*}
Rotacje nie zmieniają porządku inorder węzłów w~żadnym z~poddrzew $\alpha$, $\beta$ i~$\gamma$, dlatego po przeprowadzeniu lewej rotacji wartości pola $f$ wynoszą
\begin{align*}
	\attrib{x}{f} &= \attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes\attrib{r_\beta}{f}, \\
	\attrib{y}{f} &= \attrib{r_\alpha}{f}\otimes\attrib{x}{a}\otimes\attrib{r_\beta}{f}\otimes\attrib{y}{a}\otimes\attrib{r_\gamma}{f}
\end{align*}
i~mogą zostać obliczone w~czasie $O(1)$.
Rozumowanie w~przypadku prawej rotacji przeprowadza się analogicznie.

W~drzewie czerwono-czarnym $T$ zdefiniujmy teraz dla każdego węzła pole $a$ przyjmujące wartość 0 dla liści drzewa (reprezentowanych przez \attrib{T}{nil}) oraz 1 dla jego węzłów wewnętrznych.
Jeśli operacją $\otimes$ będzie zwykłe dodawanie, to wartość \attrib{x}{f} będzie rozmiarem poddrzewa o~korzeniu w~$x$, czyli pole $f$ będzie identyczne z~polem \id{size} z~drzew statystyk pozycyjnych.
Dzięki powyżej przedstawionej argumentacji pole \id{size} może być aktualizowane w~czasie $O(1)$ po każdym wykonaniu rotacji w~drzewie $T$.

\exercise %14.2-5
Do zaimplementowania tej operacji potrzebna nam będzie pomocnicza procedura wyszukująca w~drzewie czerwono-czarnym węzeł o~najmniejszym kluczu większym lub równym podanej wartości.
\begin{codebox}
\Procname{$\proc{RB-Search-Upper-Bound}(T,x,k)$}
\li	\If $z\gets\attrib{T}{nil}$
\li	\While \const{true}
\li		\Do \If $x=\attrib{T}{nil}$
\li				\Then \Return $y$ \label{li:rb-search-upper-bound-return-z}
				\End
\li			\If $\attrib{x}{key}=k$
\li				\Then \Return $x$ \label{li:rb-search-upper-bound-return-x}
				\End
\li			\If $k<\attrib{x}{key}$
\li				\Then $z\gets x$
\li					$x\gets\attrib{x}{left}$
\li				\Else $x\gets\attrib{x}{right}$
				\End
\end{codebox}
Jest to modyfikacja procedury \proc{Iterative-RB-Search}, która z~kolei jest wersją procedury \proc{Iterative-Tree-Search} przystosowaną do drzew czerwono-czarnych.
W~drzewie $T$ wyszukiwany jest węzeł o~kluczu $k$ i~jeśli istnieje, to zostaje zwrócony w~linii \ref{li:rb-search-upper-bound-return-x}.
W~przeciwnym przypadku w~wierszu \ref{li:rb-search-upper-bound-return-z} następuje zwrócenie następnika węzła o~kluczu $k$, gdyby znajdował się on w~drzewie $T$.
Zmienna $z$ w~kolejnych iteracjach pętli \kw{while} wskazuje na węzeł będący przodkiem aktualnie testowanego węzła $x$ znajdującego się w~lewym poddrzewie $z$, albo na \attrib{T}{nil}, jeżeli węzeł taki nie istnieje w~$T$.
Poza utrzymywaniem odpowiedniej wartości zmiennej $z$, procedura wykonuje te same działania, co \proc{Iterative-RB-Search}, a~zatem działa w~czasie $O(\lg n)$ dla drzewa $T$ o~$n$ węzłach.

Rozważymy także modyfikację operacji następnika, \proc{RB-Subtree-Successor}, która przyjmuje dodatkowy, trzeci parametr $z$ i~znajduje następnik węzła $x$ w~poddrzewie o~korzeniu $z$.
Jeśli taki węzeł nie istnieje w~tym poddrzewie, to zwracane jest \attrib{T}{nil}.
Modyfikacja polega na dodaniu następującego fragmentu między wiersz 2 i~3 w~\proc{RB-Successor}, co nie zwiększa czasu działania tej procedury:
\begin{codebox}
\zi	\If $x=\proc{RB-Maximum}(T,z)$
\zi		\Then \Return \attrib{T}{nil}
		\End
\end{codebox}

Następujący algorytm stanowi implementację szukanej operacji.
Przyjmuje on dodatkowo jako parametr drzewo $T$ potrzebne do odwołania się do \attrib{T}{nil} i~wypisuje szukane klucze w~porządku niemalejącym.
\begin{codebox}
\Procname{$\proc{RB-Enumerate}(T,x,a,b)$}
\li $z\gets\proc{RB-Search-Upper-Bound}(T,x,a)$ \label{li:rb-enumerate-initial-node}
\li	\While $z\ne\attrib{T}{nil}$ i~$a\le\attrib{z}{key}\le b$
\li		\Do wypisz \attrib{z}{key}
\li			$z\gets\proc{RB-Subtree-Successor}(T,x,z)$ \label{li:rb-enumerate-next-node}
		\End
\end{codebox}
Zmienna $z$ jest inicjalizowana na węzeł o~kluczu $k\ge a$ z~poddrzewa o~korzeniu w~$x$.
Jeśli węzeł taki nie istnieje (bo poddrzewo $x$ zawiera klucze mniejsze od $a$), to $z=\attrib{T}{nil}$ i~procedura kończy działanie.
W~przeciwnym przypadku następuje seria wywołań operacji następnika $y$ w~wierszu \ref{li:rb-enumerate-next-node}, aż do wyczerpania węzłów w~poddrzewie $x$ albo odnalezienia węzła o~kluczu przekraczającym $b$.

Wywołanie z~linii \ref{li:rb-enumerate-initial-node} zajmuje czas $O(\lg n)$.
Na mocy \refExercise{12.2-8} niezależnie od tego, od którego węzła rozpoczniemy, seria $m$ wywołań operacji następnika w~drzewie o~wysokości $h=O(\lg n)$ potrzebuje czasu $O(m+\lg n)$, co stanowi czas działania przedstawionego algorytmu.
