\problem{Sklejanie i~rozbijanie 2-3-4 drzew} %18-2

\subproblem %18-2(a)
Przez wprowadzenie atrybutu \id{height} atrybut \id{leaf} jest teraz zbędny, dlatego pominiemy go w~implementacji 2-3-4 drzew.
Operacje tworzenia pustego drzewa, wyszukiwania, wstawiania i~usuwania dla 2-3-4 drzew opierają się w~dużej mierze na analogicznych operacjach dla B-drzew, z~kilkoma modyfikacjami.
Po pierwsze w~implementacjach tych operacji rezygnujemy ze stosowania zmiennej $t$, zastępując ją przez minimalny stopień 2-3-4 drzew, czyli 2.
Ponadto każde odwołanie do pola \id{leaf} zamieniamy na odpowiednie odwołanie do pola \id{height}.
Warunek \attrib{x}{leaf} zastępujemy przez $\attrib{x}{height}=0$, a~warunek $\attrib{x}{leaf}=\const{false}$ -- przez $\attrib{x}{height}>0$.
W~wersji procedury \proc{B-Tree-Create} dla 2-3-4 drzew inicjalizacja pola \id{leaf} na \const{true} jest zastąpiona przez inicjalizację pola \id{height} na 0.
W~procedurze rozbijania węzła w~2-3-4 drzewie kopiowanie pola \id{leaf} z~węzła $y$ do $z$ jest zastąpione przez kopiowanie pola \id{height} między tymi węzłami.
Wreszcie, w~procedurze wstawiania do 2-3-4 drzewa, jeśli w~wyniku rozbicia korzenia $r$ powstanie nowy korzeń, to jego pole \id{height} jest inicjalizowane na $\attrib{r}{height}+1$.

Utrzymywanie i~aktualizowanie atrybutu \id{height} nie wpływa na asymptotyczny czas działania poszczególnych operacji, ponieważ w~B-drzewach -- a~więc w~szczególności w~2-3-4 drzewach -- węzły są zawsze tworzone i~usuwane na głębokości 0, dzięki czemu wysokość żadnego poddrzewa nie ulega wtedy zmianie.

\subproblem %18-2(b)
Ogólna koncepcja operacji sklejania polega na wstawieniu klucza $k$ na odpowiednią wysokość w~wyższym drzewie, a~następnie podpięciu niższego drzewa do węzła, do którego trafiło $k$.
Dzięki temu wynikowe drzewo będzie poprawnym 2-3-4 drzewem -- jego wszystkie liście znajdą się na tej samej głębokości.
Do realizacji tego zadania będzie nam potrzebna zmodyfikowana procedura wstawiania klucza do 2-3-4 drzewa, umiejscawiająca klucz na zadanej wysokości $h>0$ w~tym drzewie.
W~porównaniu do zwykłego wstawiania do 2-3-4 drzewa opisanego w~punkcie (a), w~nowej procedurze wysokość węzła $x$ będzie porównywana nie z~0, ale z~$h$, a~oprócz kluczy węzła $x$ będą przesuwane też odpowiednie wskaźniki do synów $x$.
Procedura dodatkowo zwróci jako wynik zmodyfikowany węzeł $x$.

Podczas sklejania osobno obsłużymy sytuację, gdy jedno z~drzew $T'$ lub $T''$ jest puste.
Wystarczy wówczas wstawić klucz $k$ do drugiego drzewa na wysokość 0, czyli do jednego z~jego liści, wykorzystując w~tym celu zwykłą procedurę wstawiania do 2-3-4 drzewa.

Załóżmy teraz, że oba drzewa są niepuste i~oznaczmy przez $h'$ wysokość drzewa $T'$, a~przez $h''$ -- wysokość drzewa $T''$.
Jeżeli $h'<h''$, to wstawiamy klucz $k$ do drzewa $T''$, do jego węzła $x$ znajdującego się na wysokości $h'+1$, wywołując opisaną powyżej zmodyfikowaną procedurę wstawiania.
Ponieważ klucz $k$ jest mniejszy od każdego klucza w~drzewie $T''$, to w~węźle $x$ zajął on pierwszą pozycję, czyli \attribxx{x}{key_1}.
Wskaźnik \attribxx{x}{c_1} ustawiamy następnie na korzeń drzewa $T'$, efektywnie czyniąc to drzewo jednym z~poddrzew węzła $x$.
Wynikowym drzewem jest tu $T''$.

Przypadek, gdy $h'>h''$, jest symetryczny do poprzedniego.
Klucz $k$ ląduje tym razem w~węźle $x$ drzewa $T'$ na wysokości $h''+1$, a~dokładniej w~\attribxx{x}{key_{\attrib{x}{n}}} (po uprzedniej inkrementacji pola \attrib{x}{n}).
Przyłączenie drzewa $T''$ polega na aktualizacji wskaźnika \attribxx{x}{c_{\attrib{x}{n}+1}} na jego korzeń.
Zwracane jest w~wyniku drzewo $T'$.

W~sytuacji, w~której wysokości obu drzew są równe, pozostaje nam utworzenie i~zwrócenie nowego drzewa $T$ z~korzeniem zawierającym jedynie klucz $k$ oraz $T'$, $T''$ w~roli jego poddrzew.

Cały powyższy opis formalizuje następujący pseudokod.
Wykorzystujemy w~nim wywołania do procedur \proc{2-3-4-Tree-Create}, \proc{2-3-4-Tree-Insert} i~\proc{2-3-4-Tree-Insert-At} -- odpowiednio, tworzenia nowego 2-3-4 drzewa, zwykłego wstawiania klucza do 2-3-4 drzewa oraz wstawiania klucza do 2-3-4 drzewa na zadaną wysokość.
\begin{codebox}
    \Procname{$\proc{2-3-4-Tree-Join}(T',T'',k)$}
    \li \If $\attrib{\attrib{T'}{root}}{n}=0$
    \li     \Then $\proc{2-3-4-Tree-Insert}(T'',k)$
    \li         \Return $T''$
            \End
    \li \If $\attrib{\attrib{T''}{root}}{n}=0$
    \li     \Then $\proc{2-3-4-Tree-Insert}(T',k)$
    \li         \Return $T'$
            \End
    \li $h'\gets\attrib{\attrib{T'}{root}}{height}$
    \li $h''\gets\attrib{\attrib{T''}{root}}{height}$
    \li \If $h'<h''$
    \li     \Then $x\gets\proc{2-3-4-Tree-Insert-At}(T'',k,h'+1)$
    \li         $\attribxx{x}{c_1}\gets\attrib{T'}{root}$
    \li         \Return $T''$
            \End
    \li \If $h'>h''$
    \li     \Then $x\gets\proc{2-3-4-Tree-Insert-At}(T',k,h''+1)$
    \li         $\attribxx{x}{c_{\attrib{x}{n}+1}}\gets\attrib{T''}{root}$
    \li         \Return $T'$
            \End
    \li $\proc{2-3-4-Tree-Create}(T)$
    \li $\proc{2-3-4-Tree-Insert}(T,k)$
    \li $\attrib{\attrib{T}{root}}{height}\gets h'+1$
    \li $\attribxx{\attrib{T}{root}}{c_1}\gets\attrib{T'}{root}$
    \li $\attribxx{\attrib{T}{root}}{c_2}\gets\attrib{T''}{root}$
    \li \Return $T$
\end{codebox}

Nietrudno zauważyć, że algorytm wykonuje co najwyżej $|h'-h''+1|$ wywołań rekurencyjnych w~procedurach \proc{2-3-4-Tree-Insert} lub \proc{2-3-4-Tree-Insert-At}, zaś pozostałe operacje wnoszą koszt stały.
Stąd algorytm działa w~czasie $O(1+|h'-h''|)$.

\subproblem %18-2(c)
Przypatrzmy się działaniu operacji wyszukiwania klucza $k$ w~drzewie $T$, która oczywiście podąża ścieżką $p$.
Pracując na węźle $x$, procedura przegląda wszystkie klucze $k'$ węzła $x$ nieprzekraczające $k$.
W~przypadku nieodnalezienia $k$ w~$x$ procedura wywoła się rekurencyjne dla syna $x$ o~kluczach większych niż każdy dotychczas przejrzany $k'$.
Oznacza to, że procedura przejrzy we wszystkich odwiedzonych węzłach klucze $k_1'$, $k_2'$, \dots, $k_m'$, $k_{m+1}'=k$, w~porządku rosnącym.
Mamy więc $k_1'<k_2'<\dots<k_m'<k$.

Wybierzmy teraz dowolne $i=1$, 2, \dots, $m+1$.
Jeśli $x$ jest węzłem wewnętrznym, w~którym $k_i'=\attribxx{x}{key_j}$ dla pewnego $j$, to wszystkie klucze z~poddrzewa o~korzeniu w~\attribxx{x}{c_j} są mniejsze od $k_i'$, a~dodatkowo, gdy $i>1$, to są one też większe od $k_{i-1}'$.
Jeśli przez $T_{i-1}'$ oznaczymy wspomniane poddrzewo, a~w~przypadku, gdy $k_i'$ jest w~liściu -- drzewo puste -- to otrzymamy tezę.

Dla każdego $i=1$, 2, \dots, $m$, jeśli $T_{i-1}'$ jest poddrzewem węzła $x$, to $T_i'$ jest poddrzewem $x$ albo któregoś z~jego potomków, zatem wysokość $T_{i-1}'$ wynosi co najmniej tyle, ile wysokość $T_i'$.

Możemy rozumować analogicznie, aby pokazać, że ścieżka $p$ rozbija zbiór $S''$ na zbiór drzew $\{T_0''$, $T_1''$, \dots, $T_m''\}$ i~zbiór kluczy $\{k_1''$, $k_2''$, \dots, $k_m''\}$ takie, że $y>k_i''>z$ dla $i=1$, 2, \dots, $m$ oraz każdej pary kluczy $y\in T_{i-1}''$ i~$z\in T_i''$.
Podobnie jak w~rozbiciu zbioru $S'$, indeksy $i$ porządkują drzewa $T_i''$ nierosnąco według wysokości.

\subproblem %18-2(d)
Danymi wejściowymi operacji rozbijania dla 2-3-4 drzew jest 2-3-4 drzewo $T$ oraz klucz $k$ znajdujący się w~$T$.

Niech $S'$, $S''$ będą zbiorami kluczy $T$, odpowiednio, mniejszych od $k$ i~większych od $k$.
Do zbudowania drzew $T'$ i~$T''$ reprezentujących zbiory $S'$ i~$S''$ potrzebne nam będą rozbicia tych zbiorów opisane w~części (c).
Do ich wyznaczenia wykorzystamy procedury pomocnicze \proc{2-3-4-Tree-Left-Partition} i~\proc{2-3-4-Tree-Right-Partition}.
Poniżej podajemy pseudokod pierwszej z~nich służącej do znalezienia rozbicia zbioru $S'$.
\begin{codebox}
    \Procname{$\proc{2-3-4-Tree-Left-Partition}(T,k)$}
    \li $h\gets\attrib{\attrib{T}{root}}{height}$
    \li utwórz tablice $L[0\twodots 3h+2]$ i~$K[1\twodots 3h+2]$
    \li $m\gets0$
    \li $x\gets\attrib{T}{root}$
    \li \While \const{true}
    \li     \Do $i\gets1$
    \li     \While $i\le\attrib{x}{n}$ i~$k\ge\attribxx{x}{key_i}$
    \li         \Do $\proc{2-3-4-Tree-Create}(T^*)$
    \li             \If $\attrib{x}{height}>0$
    \li                 \Then $\attrib{T^*}{root}\gets\attribxx{x}{c_i}$
                        \End
    \li             $L[m]\gets T^*$
    \li             \If $k=\attribxx{x}{key_i}$
    \li                 \Then \Return $\langle L[0\twodots m], K[1\twodots m]\rangle$
                        \End
    \li             $m\gets m+1$
    \li             $K[m]=\attribxx{x}{key_i}$
    \li             $i\gets i+1$
                \End
    \li         $x\gets\attribxx{x}{c_i}$
            \End
\end{codebox}
Główna idea przyświecająca tej procedurze opiera się na opisie z~rozwiązania punktu (c).
Procedura przechodzi po ścieżce $p$ od korzenia $T$ do klucza $k$, który z~założenia znajduje się w~$T$, i~na każdym poziomie drzewa wyznacza elementy zbioru drzew i~elementy zbioru kluczy, wchodzące w~skład rozbicia $S'$.
Zbiory te reprezentowane są w~algorytmie przez tablice $L$ i~$K$.
Zauważmy, że na każdym z~$h+1$ poziomów drzewa $T$ co najwyżej 3 drzewa mogą zostać umieszczone w~tablicy $L$, oraz co najwyżej 3 klucze w~tablicy $K$ (z~wyjątkiem poziomu liści drzewa, który generuje co najwyżej 2 klucze).
Stąd biorą się ograniczenia na rozmiary tych tablic użyte przy ich inicjalizacji.
W~momencie odnalezienia klucza $k$ -- co jest gwarantowane na podstawie założenia -- procedura natychmiast kończy działanie, zwracając fragmenty tablic z~wyznaczonym rozbiciem.

Jak nietrudno się domyślić, procedura \proc{2-3-4-Tree-Right-Partition} jest symetryczna do powyższej.
Jedynymi różnicami w~porównaniu z~\proc{2-3-4-Tree-Left-Partition} jest odwrotna kolejność przeglądania kluczy węzłów na ścieżce $p$ oraz dodawanie do zbioru $L$ poddrzew sąsiadujących z~aktualnym kluczem od prawej strony.

W~głównej operacji rozbijania \proc{2-3-4-Tree-Split} drzewo $T'$ zostanie zbudowane przez wykonywanie sklejania kolejnych par drzew i~kluczy z~rozbicia zbioru $S'$, a~drzewo $T''$ -- symetrycznie przy użyciu rozbicia zbioru $S''$.
Moglibyśmy sklejać kolejne drzewa, zaczynając od tych najwyższych, ale taka strategia pochłania asymptotycznie wyższy czas, niż jesteśmy w~stanie osiągnąć przez odwrócenie kolejności sklejania.
\begin{codebox}
    \Procname{$\proc{2-3-4-Tree-Split}(T,k)$}
    \li $\langle L',K'\rangle\gets\proc{2-3-4-Tree-Left-Partition}(T,k)$ \label{li:2-3-4-tree-split-left-partition}
    \li $\langle L'',K''\rangle\gets\proc{2-3-4-Tree-Right-Partition}(T,k)$ \label{li:2-3-4-tree-split-right-partition}
    \li \For $i\gets\attrib{K'}{length}$ \Downto 1 \label{li:2-3-4-tree-split-left-tree-create-begin}
    \li     \Do $L'[i-1]\gets\proc{2-3-4-Tree-Join}(L'[i-1],L'[i],K'[i])$
            \End \label{li:2-3-4-tree-split-left-tree-create-end}
    \li \For $i\gets\attrib{K''}{length}$ \Downto 1 \label{li:2-3-4-tree-split-right-tree-create-begin}
    \li     \Do $L''[i-1]\gets\proc{2-3-4-Tree-Join}(L''[i],L''[i-1],K'[i])$
            \End \label{li:2-3-4-tree-split-right-tree-create-end}
    \li \Return $\langle L'[0],L''[0]\rangle$
\end{codebox}

Przeanalizujmy czas działania procedury \proc{2-3-4-Tree-Split} dla drzewa $T$ o~wysokości $h$ i~$n$ kluczach.
Oczywiście czas potrzebny na wyznaczenie rozbić zbiorów $S'$ i~$S''$ w~wierszach \ref{li:2-3-4-tree-split-left-partition} i~\ref{li:2-3-4-tree-split-right-partition} wynosi tyle samo, co czas (dwukrotnego) odszukania w~$T$ klucza $k$, czyli $O(h)$.
Niech $m'=\attrib{L'}{length}$ i~$m''=\attrib{L''}{length}$.
Jak zauważyliśmy wcześniej, $m'\le3h+3$ i~$m''\le3h+3$.
Oznaczmy przez $h_i'$ dla $i=0$, 1, \dots, $m'-1$ wysokość drzewa $T_i'$ znajdującego się tuż po linii \ref{li:2-3-4-tree-split-right-partition} w~$L'[i]$ i~podobnie, przez $h_i''$ dla $i=0$, 1, \dots, $m''-1$ wysokość drzewa $T_i''$ znajdującego się wtedy w~$L''[i]$.
Na mocy obserwacji z~punktu (c) mamy, że oba te ciągi wysokości są nierosnące, ponadto $h_m'-h_0'\le h$ i~$h_m''-h_0''\le h$.
Czas działania utworzenia $T'$ w~wierszach \doubledash{\ref{li:2-3-4-tree-split-left-tree-create-begin}}{\ref{li:2-3-4-tree-split-left-tree-create-end}} wynosi zatem
\[
    \sum_{i=1}^mO(1+|h_i'-h_{i-1}'|) = O\biggl(\sum_{i=1}^m(1+(h_i'-h_{i-1}'))\biggr) = O(m+h_m'-h_0') = O(h),
\]
co z~tw.\ 12.1 daje $O(\lg n)$.
Oczywiście analogicznie otrzymuje się identyczne oszacowanie na czas budowy drzewa $T''$ w~liniach \doubledash{\ref{li:2-3-4-tree-split-right-tree-create-begin}}{\ref{li:2-3-4-tree-split-right-tree-create-end}}.
A~zatem czas działania operacji rozbijania 2-3-4 drzewa wynosi $O(\lg n)$.
