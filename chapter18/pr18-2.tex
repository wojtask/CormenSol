\problem{Sklejanie i~rozbijanie 2-3-4 drzew} %18-2

\subproblem %18-2(a)
Przez wprowadzenie atrybutu \id{height} atrybut \id{leaf} jest teraz zbędny, dlatego pominiemy go w~implementacji 2-3-4 drzew.
Operacje tworzenia pustego drzewa, wyszukiwania, wstawiania i~usuwania dla 2-3-4 drzew opierają się w~dużej mierze na analogicznych operacjach dla B-drzew, z~kilkoma modyfikacjami.
Po pierwsze w~implementacjach tych operacji rezygnujemy ze stosowania zmiennej $t$, zastępując ją przez minimalny stopień 2-3-4 drzew, czyli 2.
Ponadto każde odwołanie do pola \id{leaf} zamieniamy na odpowiednie odwołanie do pola \id{height}.
Warunek \attrib{x}{leaf} zastępujemy przez $\attrib{x}{height}=0$, a~warunek $\attrib{x}{leaf}=\const{false}$ -- przez $\attrib{x}{height}>0$.
W~wersji procedury \proc{B-Tree-Create} dla 2-3-4 drzew inicjalizacja pola \id{leaf} na \const{true} jest zastąpiona przez inicjalizację pola \id{height} na 0.
W~procedurze rozbijania węzła w~2-3-4 drzewie kopiowanie pola \id{leaf} z~węzła $y$ do $z$ jest zastąpione przez kopiowanie pola \id{height} między tymi węzłami.
Wreszcie, w~procedurze wstawiania do 2-3-4 drzewa, jeśli w~wyniku rozbicia korzenia $r$ powstanie nowy korzeń, to jego pole \id{height} jest inicjalizowane na $\attrib{r}{height}+1$.

Utrzymywanie i~aktualizowanie atrybutu \id{height} nie wpływa na asymptotyczny czas działania poszczególnych operacji, ponieważ w~B-drzewach -- a~więc w~szczególności w~2-3-4 drzewach -- węzły są zawsze tworzone i~usuwane na głębokości 0, dzięki czemu wysokość żadnego poddrzewa nie ulega wtedy zmianie.

\subproblem %18-2(b)
Ogólna koncepcja operacji sklejania polega na wstawieniu klucza $k$ na odpowiednią wysokość w~wyższym drzewie, a~następnie podpięciu niższego drzewa do węzła, do którego trafiło $k$.
Dzięki temu wynikowe drzewo będzie poprawnym 2-3-4 drzewem -- jego wszystkie liście znajdą się na tej samej głębokości.
Do realizacji tego zadania będzie nam potrzebna zmodyfikowana procedura wstawiania klucza do 2-3-4 drzewa, umiejscawiająca klucz na zadanej wysokości $h>0$ w~tym drzewie.
W~porównaniu do zwykłego wstawiania do 2-3-4 drzewa opisanego w~punkcie (a), w~nowej procedurze wysokość węzła $x$ będzie porównywana nie z~0, ale z~$h$, a~oprócz kluczy węzła $x$ będą przesuwane też odpowiednie wskaźniki do synów $x$.
Procedura dodatkowo zwróci jako wynik zmodyfikowany węzeł $x$.

Podczas sklejania osobno obsłużymy sytuację, gdy jedno z~drzew $T'$ lub $T''$ jest puste.
Wystarczy wówczas wstawić klucz $k$ do drugiego drzewa na wysokość 0, czyli do jednego z~jego liści, wykorzystując w~tym celu zwykłą procedurę wstawiania do 2-3-4 drzewa.

Załóżmy teraz, że oba drzewa są niepuste i~oznaczmy przez $h'$ wysokość drzewa $T'$, a~przez $h''$ -- wysokość drzewa $T''$.
Jeżeli $h'<h''$, to wstawiamy klucz $k$ do drzewa $T''$, do jego węzła $x$ znajdującego się na wysokości $h'+1$, wywołując opisaną powyżej zmodyfikowaną procedurę wstawiania.
Ponieważ klucz $k$ jest mniejszy od każdego klucza w~drzewie $T''$, to w~węźle $x$ zajął on pierwszą pozycję, czyli \attribxx{x}{key_1}.
Wskaźnik \attribxx{x}{c_1} ustawiamy następnie na korzeń drzewa $T'$, efektywnie czyniąc to drzewo jednym z~poddrzew węzła $x$.
Wynikowym drzewem jest tu $T''$.

Przypadek, gdy $h'>h''$, jest symetryczny do poprzedniego.
Klucz $k$ ląduje tym razem w~węźle $x$ drzewa $T'$ na wysokości $h''+1$, a~dokładniej w~\attribxx{x}{key_{\attrib{x}{n}}} (po uprzedniej inkrementacji pola \attrib{x}{n}).
Przyłączenie drzewa $T''$ polega na aktualizacji wskaźnika \attribxx{x}{c_{\attrib{x}{n}+1}} na jego korzeń.
Zwracane jest w~wyniku drzewo $T'$.

W~sytuacji, w~której wysokości obu drzew są równe, pozostaje nam utworzenie i~zwrócenie nowego drzewa $T$ z~korzeniem zawierającym jedynie klucz $k$ oraz $T'$, $T''$ w~roli jego poddrzew.

Cały powyższy opis formalizuje następujący pseudokod.
Wykorzystujemy w~nim wywołania do procedur \proc{2-3-4-Tree-Create}, \proc{2-3-4-Tree-Insert} i~\proc{2-3-4-Tree-Insert-At} -- odpowiednio, tworzenia nowego 2-3-4 drzewa, zwykłego wstawiania klucza do 2-3-4 drzewa oraz wstawiania klucza do 2-3-4 drzewa na zadaną wysokość.
\begin{codebox}
    \Procname{$\proc{2-3-4-Tree-Join}(T',T'',k)$}
    \li \If $\attrib{\attrib{T'}{root}}{n}=0$
    \li     \Then $\proc{2-3-4-Tree-Insert}(T'',k)$
    \li         \Return $T''$
            \End
    \li \If $\attrib{\attrib{T''}{root}}{n}=0$
    \li     \Then $\proc{2-3-4-Tree-Insert}(T',k)$
    \li         \Return $T'$
            \End
    \li $h'\gets\attrib{\attrib{T'}{root}}{height}$
    \li $h''\gets\attrib{\attrib{T''}{root}}{height}$
    \li \If $h'<h''$
    \li     \Then $x\gets\proc{2-3-4-Tree-Insert-At}(T'',k,h'+1)$
    \li         $\attribxx{x}{c_1}\gets\attrib{T'}{root}$
    \li         \Return $T''$
            \End
    \li \If $h'>h''$
    \li     \Then $x\gets\proc{2-3-4-Tree-Insert-At}(T',k,h''+1)$
    \li         $\attribxx{x}{c_{\attrib{x}{n}+1}}\gets\attrib{T''}{root}$
    \li         \Return $T'$
            \End
    \li $\proc{2-3-4-Tree-Create}(T)$
    \li $\proc{2-3-4-Tree-Insert}(T,k)$
    \li $\attrib{\attrib{T}{root}}{height}\gets h'+1$
    \li $\attribxx{\attrib{T}{root}}{c_1}\gets\attrib{T'}{root}$
    \li $\attribxx{\attrib{T}{root}}{c_2}\gets\attrib{T''}{root}$
    \li \Return $T$
\end{codebox}

Nietrudno zauważyć, że algorytm wykonuje co najwyżej $|h'-h''+1|$ wywołań rekurencyjnych w~procedurach \proc{2-3-4-Tree-Insert} lub \proc{2-3-4-Tree-Insert-At}, zaś pozostałe operacje wnoszą koszt stały.
Stąd algorytm działa w~czasie $O(1+|h'-h''|)$.

\subproblem %18-2(c)
\subproblem %18-2(d)
