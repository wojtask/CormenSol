\subchapter{Podstawowe operacje na B-drzewach}

\exercise %18.2-1
B-drzewa zostały zilustrowane na rys.\ \ref{fig:18.2-1}.
\begin{figure}[!ht]
	\centering \input{fig18.2-1}
	\caption{Ilustracja wstawiania do B-drzewa.} \label{fig:18.2-1}
\end{figure}

\exercise %18.2-2
Jedyna sytuacja z~nadmiarowym wykonaniem operacji \proc{Disk-Read} może mieć miejsce, gdy klucz wstawiany jest do drzewa o~pełnym korzeniu.
W~procedurze \proc{B-Tree-Insert} w~trakcie rozbijania korzenia w~wywołaniu z~wiersza 8 tworzony jest nowy węzeł, który z~automatu trafia do pamięci wewnętrznej.
Następnie wołana jest procedura \proc{B-Tree-Insert-Nonfull} z~nowym korzeniem jako argumentem.
Nadmiarowe wczytanie do pamięci wewnętrznej może się wówczas wydarzyć w~linii 12 tejże procedury.

Z~kolei żaden zapis na dysk nie jest nadmiarowy.
Wywołanie \proc{Disk-Write} w~linii 8 procedury \proc{B-Tree-Insert-Nonfull}, jak również w~liniach 17 oraz 19 procedury \proc{B-Tree-Split-Child} poprzedzone są aktualizacjami pola $n$ zapisywanych węzłów, zaś w~linii 18 ostatniej procedury zapisywany jest nowo utworzony węzeł.

\exercise %18.2-3
Operacja znajdowania minimalnego klucza w~B-drzewie jest uogólnieniem analogicznej operacji dla drzew BST.
Gdy w~danej iteracji odwiedzany jest węzeł wewnętrzny $x$, to w~kolejnej odwiedzony zostanie węzeł $\attrib{x}{c_1}$.
Po dotarciu do liścia $x$ zwrócony zostanie najmniejszy jego klucz, czyli $\attrib{x}{key_1}$.
\begin{codebox}
\Procname{$\proc{B-Tree-Minimum}(x)$}
\li	\While $\attrib{x}{leaf}=\const{false}$
\li		\Do $\proc{Disk-Read}(\attribxx{x}{c_1})$
\li     $x\gets\attribxx{x}{c_1}$
		\End
\li	\Return $\attribxx{x}{key_1}$
\end{codebox}

Podamy też pseudokod operacji znajdowania maksymalnego klucza, gdyż potrzebna nam ona będzie w~implementacji wyznaczania poprzednika.
Operacja różni się od \proc{B-Tree-Minimum} tym, że porusza się po skrajnie prawych synach węzłów wewnętrznych i~zwraca największy klucz napotkanego liścia.
\begin{codebox}
\Procname{$\proc{B-Tree-Maximum}(x)$}
\li	\While $\attrib{x}{leaf}=\const{false}$
\li		\Do $\proc{Disk-Read}(\attribxx{x}{c_{\attrib{x}{n}+1}})$
\li     $x\gets\attribxx{x}{c_{\attrib{x}{n}+1}}$
		\End
\li	\Return $\attribxx{x}{key_{\attrib{x}{n}}}$
\end{codebox}

Zastanówmy się teraz, jak wyznaczyć poprzednik klucza $k=\attribxx{x}{key_i}$, gdzie $x$ jest węzłem B-drzewa $T$.
Jeżeli $x$ jest węzłem wewnętrznym, to poprzednikiem $k$ jest największy klucz poddrzewa $\attribxx{x}{c_i}$.
W~przeciwnym przypadku szukaną wartością jest $\attribxx{x}{key_{i-1}}$ (gdy $i>1$) albo może znajdować się ona w~jednym z~przodków węzła $x$.
W~implementacji B-drzew nie posługujemy się wskaźnikami do ojców, dlatego zamiast poruszać się w~górę drzewa jak w~\proc{Tree-Predecessor} (podrozdział 12.2), będziemy symulować wyszukiwanie klucza $k$ przez schodzenie w~dół drzewa, począwszy od korzenia.
W~każdym kroku tego wyszukiwania zapamiętamy klucz mniejszy od szukanego, który posłużył do wskazania poddrzewa do następnego kroku.
Jeśli takiego klucza nie uda się wyznaczyć, będzie to oznaczać, że poprzednik klucza $k$ nie istnieje.

Procedura przyjmuje na wejściu drzewo $T$, jego węzeł $x$ oraz indeks $i$ i~zwraca poprzednik $k'$ klucza $k=\attribxx{x}{key_i}$ albo \const{nil}.
\begin{codebox}
\Procname{$\proc{B-Tree-Predecessor}(T,x,i)$}
\li \If $\attrib{x}{leaf}=\const{false}$
\li   \Then $\proc{Disk-Read}(\attribxx{x}{c_i})$
\li     \Return $\proc{B-Tree-Maximum}(\attribxx{x}{c_i})$
    \End
\li \If $i>1$
\li   \Then \Return \attribxx{x}{key_{i-1}}
    \End
\li $k\gets\attribxx{x}{key_i}$
\li $k'\gets\const{nil}$
\li $y\gets\attrib{T}{root}$
\li \While $y\ne x$
\li   \Do $j\gets1$
\li   \While $j\le\attrib{y}{n}$ i~$k>\attribxx{y}{key_j}$
\li     \Do $j\gets j+1$
      \End
\li   \If $j>1$
\li     \Then $k'\gets\attribxx{y}{key_{j-1}}$
      \End
\li   $\proc{Disk-Read}(\attribxx{y}{c_j})$
\li   $y\gets\attribxx{y}{c_j}$
    \End
\li \Return $k'$
\end{codebox}

\exercise %18.2-4
W~rozwiązaniu posługujemy się pojęciem \textbf{prawego kręgosłupa} B-drzewa.
Definiujemy je analogicznie do problemu \refProblem{13-4} w~przypadku drzew wyszukiwań binarnych.

Zachodzi następujące twierdzenie:

\medskip
\noindent\textit{Niech\/ $T$ będzie B-drzewem o~minimalnym stopniu\/ $2$, do którego wstawiono kolejno klucze\/ $1$,\/ $2$,\/ \dots,\/ $n-1$.
Podczas wstawiania klucza\/ $n$ węzeł drzewa\/ $T$ na wysokości\/ $h$ jest rozbijany tylko wtedy, gdy znajduje się na prawym kręgosłupie\/ $T$ oraz\/ $n=2^{h+1}k+h$, gdzie\/ $k\ge2$.}
\begin{proof}
	Dowód przeprowadzimy przez indukcję po $h$.
	Niech $h=0$ i~niech $y$ będzie węzłem prawego kręgosłupa drzewa $T$ na wysokości 0.
	Gdy $n\le3$, to drzewo $T$ składa się tylko z~węzła $y$.
	Pierwsze jego rozbicie ma miejsce, gdy $n=4$.
	Powstaje wówczas nowy korzeń drzewa $T$ i~jeszcze jeden węzeł na wysokości 0, do którego trafia klucz 4.
	Gdy $n>4$, to dla nieparzystych $n$ węzeł $y$ otrzymuje trzeci klucz, a~dla parzystych $n$ węzeł $y$ jest rozbijany, w~wyniku czego powstaje nowy węzeł $z$ na prawym kręgosłupie na wysokości 0 i~po zakończeniu wstawiania klucza $n$ w~węźle $z$ są już 2 klucze.
	Równoważnie, można powiedzieć, że węzeł na prawym kręgosłupie drzewa na wysokości 0 jest rozbijany tylko wtedy, gdy $n=2^{0+1}k+0$ dla $k\ge2$.

	Niech teraz $h>0$ i~załóżmy prawdziwość twierdzenia dla $h-1$.
	Zgodnie z~założeniem wstawienie klucza $n=2^h\cdot2+h-1$ skutkowało pierwszym rozbiciem węzła na prawym kręgosłupie $T$ na wysokości $h-1$ oraz powstaniem nowego korzenia $x$ z~jednym kluczem na wysokości $h$.
	Podczas wstawiania kolejnych kluczy węzeł $x$ może uzyskać nowy klucz tylko w~wyniku rozbicia jego syna $y$ znajdującego się na prawym kręgosłupie.
	Po dwóch takich rozbiciach w~węźle $x$ są już 3 klucze i~wstawianie kolejnego klucza rozbija $x$.
	Na podstawie założenia sytuacja taka zachodzi, gdy $n=(2^h\cdot4+h-1)+1=2^{h+1}\cdot2+h$.
	Tuż po zakończeniu wstawiania $n$ schemat powtarza się cyklicznie -- węzeł na prawym kręgosłupie na wysokości $h$ ma teraz znów tylko 1 klucz, a~jego kolejne rozbicie nastąpi po $2^h-1+2^h+1=2^{h+1}$ wstawieniach, czyli gdy $n=2^{h+1}\cdot3+h$.
\end{proof}

Oznaczmy przez $s(n)$ liczbę węzłów drzewa $T$ o~minimalnym stopniu 2 po wstawieniu do niego kolejno kluczy 1, 2, \dots, $n$.
Zgodnie z~wyżej udowodnionym twierdzeniem $s(n)$ stanowi sumę wszystkich rozbić węzłów na wszystkich wysokościach drzewa, łącznie z~liczbą utworzonych nowych korzeni.
Każdy poziom finalnego drzewa, z~wyjątkiem poziomu korzenia, wprowadzał dokładnie jeden nowy korzeń podczas wstawiania.
Liczba nowych węzłów drzewa tworzonych z~rozbicia węzłów na wysokości $h$ wynosi zatem $\lfloor(n-h)/2^{h+1}\rfloor$, skąd dostajemy
\[
	s(n) = \begin{cases}
		1, & \text{jeśli $n=1$}, \\
		\sum_{h=0}^\infty\bigl\lfloor\frac{n-h}{2^{h+1}}\bigr\rfloor, & \text{w~przeciwnym przypadku}.
	\end{cases}
\]

Aby znaleźć górne asymptotyczne oszacowanie $s(n)$, wystarczy zauważyć, że $s(n)\le n$, bo B-drzewo o~$n$ kluczach nigdy nie ma więcej niż $n$ węzłów.
Z~kolei dla oszacowania dolnego zauważmy, że dla $r>2$,
\begin{align*}
	s(2^r) &= \biggl\lfloor\frac{2^r}{2}\biggr\rfloor+\biggl\lfloor\frac{2^r-1}{2^2}\biggr\rfloor+\biggl\lfloor\frac{2^r-2}{2^3}\biggr\rfloor+\dots \\
	&= 2^{r-1}+2^{r-2}-1+2^{r-3}-1+\dots+2^1-1 \\
	&= 2^r-1-(r-1) \\
	&= 2^r-r,
\end{align*}
a~więc $s(n)\ge n-\lg n$.

\exercise %18.2-5
Zwiększenie dozwolonej liczby kluczy w~liściach pociąga za sobą konieczność modyfikacji warunku rozstrzygającego, czy węzeł B-drzewa jest pełny.
Warunek ten będzie musiał uwzględnić pole \id{leaf}, poza tym nie ulegnie on zmianie dla węzłów wewnętrznych, ale w~przypadku liści pole $n$ będzie porównywane z~nowym ograniczeniem na liczbę kluczy w~węźle.

Procedura tworzenia nowego B-drzewa nie wymaga modyfikacji, bo nie sprawdza pełności węzłów.
W~operacji wstawiania klucza do B-drzewa nową wersję warunku należy zastosować w~wierszu 2 procedury \proc{B-Tree-Insert} i~w~wierszu 13 procedury \proc{B-Tree-Insert-Nonfull}.
Jeśli węzeł $x$ jest liściem, to po wstawieniu do drzewa nowego klucza, $x$ nie stanie się węzłem wewnętrznym, dlatego nie ma obawy, że liczba kluczy w~$x$ zostanie przekroczona.

Musimy jednak pamiętać o~zmodyfikowaniu także procedury \proc{B-Tree-Split-Child}, w~której zakłada się, że wejściowy węzeł $y$ jest pełny.
Podczas rozbijania węzła $y$ mniej więcej połowa jego kluczy zostaje przeniesiona do nowego węzła $z$.
Gdy $y$ jest liściem, to jest nim także $z$ i~wtedy należy wybrać adekwatną nową liczbę liści dla tych węzłów oraz zadbać o~przeniesienie do $x$ odpowiedniego klucza z~$y$.

\exercise %18.2-6
Przeszukiwanie węzła B-drzewa wykorzystujące wyszukiwanie binarne zabiera czas $O(\lg t)$.
Całkowity czas działania tak zmodyfikowanej procedury \proc{B-Tree-Search} wynosi więc $O(\lg t\cdot\log_tn)=O(\lg n)$.
Skorzystaliśmy tu z~własności logarytmów (wzory 3.14).

\exercise %18.2-7
\note{W~rozwiązaniu przyjmujemy wartości z~treści oryginalnej:\/ $a=5$ milisekund i\/~$b=10$ mikrosekund.}

\noindent Założymy dla uproszczenia, że wykonanie pojedynczej instrukcji zajmuje procesorowi około 1 mikrosekundę.
Czas działania wyszukiwania w~B-drzewie zawierającym $n$ kluczy można wyrazić przez sumę czasu dostępu do stron dysku i~pozostałego czasu spędzonego na obliczeniach.
Zgodnie z~analizą z~Podręcznika, pierwsza z~tych wartości wynosi w~przybliżeniu $(1000a+bt)\log_tn$ mikrosekund, a~druga w~przybliżeniu $t\log_tn$ mikrosekund.
Ustalmy teraz $n$ i~potraktujmy tę sumę jako funkcję zmiennej $t$, gdzie $t\ge2$:
\[
	f_n(t) = (1000a+bt)\log_tn+t\log_tn = \frac{\ln n\cdot(1000a+(b+1)t)}{\ln t}.
\]

W~celu znalezienia minimum funkcji $f_n$ znajdujemy jej pochodną:
\[
	\frac{df_n}{dt}(t) = \frac{\ln n\cdot(b+1)\ln t-\frac{\ln n\cdot(1000a+(b+1)t)}{t}}{\ln^2t}.
\]
Pochodna zeruje się, gdy
\[
	\ln n\cdot(b+1)t\ln t = \ln n\cdot(1000a+(b+1)t),
\]
czyli, równoważnie,
\[
	t(\ln t-1) = \frac{1000a}{b+1}.
\]
Dla $t>e$ wyrażenie po lewej stronie znaku równości jest funkcją rosnącą (jako iloczyn funkcji rosnących i~dodatnich; patrz \refExercise{3.2-1}).
Nietrudno więc, szukając binarnie, wyznaczyć takie całkowite $t$, dla którego wyrażenie przyjmuje wartość po prawej stronie, czyli $5000/11$.
Rozwiązaniem jest $t=120$.
