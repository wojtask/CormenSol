\subchapter{Podstawowe operacje na B-drzewach}

\exercise %18.2-1
B-drzewa zostały zilustrowane na rys.\ \ref{fig:18.2-1}.
\begin{figure}[!ht]
	\centering \input{fig18.2-1}
	\caption{Ilustracja wstawiania do B-drzewa.} \label{fig:18.2-1}
\end{figure}

\exercise %18.2-2
Jedyna sytuacja z~nadmiarowym wykonaniem operacji \proc{Disk-Read} może mieć miejsce, gdy klucz wstawiany jest do drzewa o~pełnym korzeniu.
W~procedurze \proc{B-Tree-Insert} w~trakcie rozbijania korzenia w~wywołaniu z~wiersza 8 tworzony jest nowy węzeł, który z~automatu trafia do pamięci wewnętrznej.
Następnie wołana jest procedura \proc{B-Tree-Insert-Nonfull} z~nowym korzeniem jako argumentem.
Nadmiarowe wczytanie do pamięci wewnętrznej może się wówczas wydarzyć w~linii 12 tejże procedury.

Z~kolei żaden zapis na dysk nie jest nadmiarowy.
Wywołanie \proc{Disk-Write} w~linii 8 procedury \proc{B-Tree-Insert-Nonfull}, jak również w~liniach 17 oraz 19 procedury \proc{B-Tree-Split-Child} poprzedzone są aktualizacjami pola $n$ zapisywanych węzłów, zaś w~linii 18 ostatniej procedury zapisywany jest nowo utworzony węzeł.

\exercise %18.2-3
Operacja znajdowania minimalnego klucza w~B-drzewie jest uogólnieniem analogicznej operacji dla drzew BST.
Gdy w~danej iteracji odwiedzany jest węzeł wewnętrzny $x$, to w~kolejnej odwiedzony zostanie węzeł $\attrib{x}{c_1}$.
Po dotarciu do liścia $x$ zwrócony zostanie najmniejszy jego klucz, czyli $\attrib{x}{key_1}$.
\begin{codebox}
\Procname{$\proc{B-Tree-Minimum}(x)$}
\li	\While $\attrib{x}{leaf}=\const{false}$
\li		\Do $\proc{Disk-Read}(\attribxx{x}{c_1})$
\li     $x\gets\attribxx{x}{c_1}$
		\End
\li	\Return $\attribxx{x}{key_1}$
\end{codebox}

Podamy też pseudokod operacji znajdowania maksymalnego klucza, gdyż potrzebna nam ona będzie w~implementacji wyznaczania poprzednika.
Operacja różni się od \proc{B-Tree-Minimum} tym, że porusza się po skrajnie prawych synach węzłów wewnętrznych i~zwraca największy klucz napotkanego liścia.
\begin{codebox}
\Procname{$\proc{B-Tree-Maximum}(x)$}
\li	\While $\attrib{x}{leaf}=\const{false}$
\li		\Do $\proc{Disk-Read}(\attribxx{x}{c_{\attrib{x}{n}+1}})$
\li     $x\gets\attribxx{x}{c_{\attrib{x}{n}+1}}$
		\End
\li	\Return $\attribxx{x}{key_{\attrib{x}{n}}}$
\end{codebox}

Zastanówmy się teraz, jak wyznaczyć poprzednik klucza $k=\attribxx{x}{key_i}$, gdzie $x$ jest węzłem B-drzewa $T$.
Jeżeli $x$ jest węzłem wewnętrznym, to poprzednikiem $k$ jest największy klucz poddrzewa $\attribxx{x}{c_i}$.
W~przeciwnym przypadku szukaną wartością jest $\attribxx{x}{key_{i-1}}$ (gdy $i>1$) albo może znajdować się ona w~jednym z~przodków węzła $x$.
W~implementacji B-drzew nie posługujemy się wskaźnikami do ojców, dlatego zamiast poruszać się w~górę drzewa jak w~\proc{Tree-Predecessor} (podrozdział 12.2), będziemy symulować wyszukiwanie klucza $k$ przez schodzenie w~dół drzewa, począwszy od korzenia.
W~każdym kroku tego wyszukiwania zapamiętamy klucz mniejszy od szukanego, który posłużył do wskazania poddrzewa do następnego kroku.
Jeśli takiego klucza nie uda się wyznaczyć, będzie to oznaczać, że poprzednik klucza $k$ nie istnieje.

Procedura przyjmuje na wejściu drzewo $T$, jego węzeł $x$ oraz indeks $i$ i~zwraca poprzednik $k'$ klucza $k=\attribxx{x}{key_i}$ albo \const{nil}.
\begin{codebox}
\Procname{$\proc{B-Tree-Predecessor}(T,x,i)$}
\li \If $\attrib{x}{leaf}=\const{false}$
\li   \Then $\proc{Disk-Read}(\attribxx{x}{c_i})$
\li     \Return $\proc{B-Tree-Maximum}(\attribxx{x}{c_i})$
    \End
\li \If $i>1$
\li   \Then \Return \attribxx{x}{key_{i-1}}
    \End
\li $k\gets\attribxx{x}{key_i}$
\li $k'\gets\const{nil}$
\li $y\gets\attrib{T}{root}$
\li \While $y\ne x$
\li   \Do $j\gets1$
\li   \While $j\le\attrib{y}{n}$ i~$k>\attribxx{y}{key_j}$
\li     \Do $j\gets j+1$
      \End
\li   \If $j>1$
\li     \Then $k'\gets\attribxx{y}{key_{j-1}}$
      \End
\li   $\proc{Disk-Read}(\attribxx{y}{c_j})$
\li   $y\gets\attribxx{y}{c_j}$
    \End
\li \Return $k'$
\end{codebox}

\exercise %18.2-4
\exercise %18.2-5
Zwiększenie dozwolonej liczby kluczy w~liściach pociąga za sobą konieczność modyfikacji warunku rozstrzygającego, czy węzeł B-drzewa jest pełny.
Warunek ten będzie musiał uwzględnić pole \id{leaf}, poza tym nie ulegnie on zmianie dla węzłów wewnętrznych, ale w~przypadku liści pole $n$ będzie porównywane z~nowym ograniczeniem na liczbę kluczy w~węźle.

Procedura tworzenia nowego B-drzewa nie wymaga modyfikacji, bo nie sprawdza pełności węzłów.
W~operacji wstawiania klucza do B-drzewa nową wersję warunku należy zastosować w~wierszu 2 procedury \proc{B-Tree-Insert} i~w~wierszu 13 procedury \proc{B-Tree-Insert-Nonfull}.
Jeśli węzeł $x$ jest liściem, to po wstawieniu do drzewa nowego klucza, $x$ nie stanie się węzłem wewnętrznym, dlatego nie ma obawy, że liczba kluczy w~$x$ zostanie przekroczona.

Musimy jednak pamiętać o~zmodyfikowaniu także procedury \proc{B-Tree-Split-Child}, w~której zakłada się, że wejściowy węzeł $y$ jest pełny.
Podczas rozbijania węzła $y$ mniej więcej połowa jego kluczy zostaje przeniesiona do nowego węzła $z$.
Gdy $y$ jest liściem, to jest nim także $z$ i~wtedy należy wybrać adekwatną nową liczbę liści dla tych węzłów oraz zadbać o~przeniesienie do $x$ odpowiedniego klucza z~$y$.

\exercise %18.2-6
Przeszukiwanie węzła B-drzewa wykorzystujące wyszukiwanie binarne zabiera czas $O(\lg t)$.
Całkowity czas działania tak zmodyfikowanej procedury \proc{B-Tree-Search} wynosi więc $O(\lg t\cdot\log_tn)=O(\lg n)$.
Skorzystaliśmy tu z~własności logarytmów (wzory 3.14).

\exercise %18.2-7
\note{W~rozwiązaniu przyjmujemy wartości z~treści oryginalnej:\/ $a=5$ milisekund i\/~$b=10$ mikrosekund.}

\noindent Założymy dla uproszczenia, że wykonanie pojedynczej instrukcji zajmuje procesorowi około 1 mikrosekundę.
Czas działania wyszukiwania w~B-drzewie zawierającym $n$ kluczy można wyrazić przez sumę czasu dostępu do stron dysku i~pozostałego czasu spędzonego na obliczeniach.
Zgodnie z~analizą z~Podręcznika, pierwsza z~tych wartości wynosi w~przybliżeniu $(1000a+bt)\log_tn$ mikrosekund, a~druga w~przybliżeniu $t\log_tn$ mikrosekund.
Ustalmy teraz $n$ i~potraktujmy tę sumę jako funkcję zmiennej $t$, gdzie $t\ge2$:
\[
	f_n(t) = (1000a+bt)\log_tn+t\log_tn = \frac{\ln n\cdot(1000a+(b+1)t)}{\ln t}.
\]

W~celu znalezienia minimum funkcji $f_n$ znajdujemy jej pochodną:
\[
	\frac{df_n}{dt}(t) = \frac{\ln n\cdot(b+1)\ln t-\frac{\ln n\cdot(1000a+(b+1)t)}{t}}{\ln^2t}.
\]
Pochodna zeruje się, gdy
\[
	\ln n\cdot(b+1)t\ln t = \ln n\cdot(1000a+(b+1)t),
\]
czyli, równoważnie,
\[
	t(\ln t-1) = \frac{1000a}{b+1}.
\]
Dla $t>e$ wyrażenie po lewej stronie znaku równości jest funkcją rosnącą (jako iloczyn funkcji rosnących i~dodatnich; patrz \refExercise{3.2-1}).
Nietrudno więc, szukając binarnie, wyznaczyć takie całkowite $t$, dla którego wyrażenie przyjmuje wartość po prawej stronie, czyli $5000/11$.
Rozwiązaniem jest $t=120$.
