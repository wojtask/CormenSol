\subchapter{Operacja wstawiania}
\note{Linia 15 procedury \proc{RB-Insert-Fixup} powinna mówić również o~zamianie lewej rotacji na prawą i~vice versa.}
\bignegskip

\exercise %13.3-1
Pokolorowanie węzła $z$ na czarno mogłoby spowodować naruszenie własności 5 drzewa czerwono-czarnego, podczas gdy procedura \proc{RB-Insert-Fixup} operuje na drzewie, w~którym własność ta jest zachowana i~nie narusza jej w~trakcie swojego działania.

\exercise %13.3-2
Na rys.\ \ref{fig:13.3-2} zilustrowano ciąg operacji wstawiania węzłów do drzewa czerwono-czarnego.
\begin{figure}[!ht]
	\centering \input{fig13.3-2}
	\caption{Drzewa czerwono-czarne powstałe po wstawieniu elementów 41, 38, 31, 12, 19, 8 kolejno do początkowo pustego drzewa.
	{\sffamily\bfseries(a)} Po wstawieniu pierwszego elementu drzewo składa się tylko z~korzenia, który początkowo ma kolor czerwony.
	Przywrócenie własności 2 drzewa czerwono-czarnego następuje w~linii 15 procedury \proc{RB-Insert-Fixup}.
	{\sffamily\bfseries(b)} Dodanie węzła o~kluczu 38 nie powoduje naruszenia żadnej własności drzewa czerwono-czarnego.
	{\sffamily\bfseries\doubledash{(c)}{(f)}} Wstawienie każdego kolejnego elementu produkuje drzewo, w~którym naruszona jest własność 4, przywracana następnie za pomocą procedury \proc{RB-Insert-Fixup}.} \label{fig:13.3-2}
\end{figure}

\exercise %13.3-3
Wersja rysunków 13.5 i~13.6 z~Podręcznika z~podanymi czarnymi wysokościami węzłów została zaprezentowana na rys.\ \ref{fig:13.3-3}.
Wynika z~niego, że własność 5 drzewa czerwono-czarnego faktycznie pozostaje zachowana podczas działania procedury \proc{RB-Insert-Fixup}.
\begin{figure}[!ht]
	\centering \input{fig13.3-3}
	\caption{{\sffamily\bfseries\doubledash{(a)}{(b)}} Rys.\ 13.5 z~Podręcznika uzupełniony o~czarne wysokości poszczególnych węzłów drzewa.
	{\sffamily\bfseries(c)} Uzupełniony rys.\ 13.6.} \label{fig:13.3-3}
\end{figure}

\exercise %13.3-4
Jedyny węzeł, który jest kolorowany na czerwono w~trakcie działania procedury \proc{RB-Insert-Fixup} to \attrib{\attrib{z}{p}}{p}.
Pętla \kw{while} w~tej procedurze wykonuje się tylko wtedy, gdy $z$ nie jest korzeniem.
Z~dowodu niezmiennika pętli \kw{while} wynika, że jeśli naruszona jest własność 2, to tylko wówczas, gdy $z$ jest korzeniem i~jest czerwony.
A~zatem kolorowanie węzła \attrib{\attrib{z}{p}}{p} na czerwono odbywa się jedynie w~przypadku, gdy \attrib{z}{p} jest czerwony i~nie jest to korzeń.
Stąd mamy, że węzeł \attrib{\attrib{z}{p}}{p} nie jest wartownikiem \attrib{T}{nil}, więc procedura \proc{RB-Insert-Fixup} nigdy nie przypisze wartownikowi koloru \const{red}.

\exercise %13.3-5
Pokażemy, że nowy węzeł wstawiony do niepustego drzewa czerwono-czarnego za pomocą procedury \proc{RB-Insert} zachowuje kolor czerwony.
Bezpośrednio przed wywołaniem pomocniczej procedury \proc{RB-Insert-Fixup}, nowo wstawiony węzeł $z$ jest czerwonym liściem.
Jeśli ojciec węzła $z$ jest czarny, to procedura zakończy działanie, a~$z$ zachowa swój kolor.
Załóżmy teraz, że ojciec węzła $z$ jest czerwony i~rozważmy przypadki, jak przy omawianiu działania procedury \proc{RB-Insert}.
Zmiany kolorów węzłów w~drzewie odbywają się tylko w~przypadkach 1 i~3, ale~w~żadnym z~nich kolor węzła $z$ nie ulega zmianie -- przekolorowywane są ewentualnie tylko jego przodkowie.
Ponieważ nowy węzeł nie jest korzeniem, to również ostatni wiersz procedury \proc{RB-Insert-Fixup} nie zaktualizuje koloru $z$ na czarny.

\exercise %13.3-6
Podczas wstawiania węzła do drzewa czerwono-czarnego w~reprezentacji bez wskaźników do ojców, do zapamiętania ścieżki od korzenia do nowego węzła użyjemy stosu.
Wstawimy do niego każdy kolejno odwiedzony węzeł drzewa, zanim wywołana zostanie procedura \proc{RB-Insert-Fixup}.
Dokładniej, między linią 4 a~5 w~procedurze \proc{RB-Insert} będziemy wywoływać $\proc{Push}(S,y)$, gdzie $S$ jest początkowo pustym stosem.
Pominiemy w~niej także linię 8.

Informacje zebrane na stosie $S$ wystarczą, ponieważ procedura \proc{RB-Insert-Fixup} korzysta ze wskaźnika $p$ jedynie na węzłach znajdujących się w~$S$.
Musimy następnie zmodyfikować procedurę \proc{RB-Insert-Fixup} tak, aby każde odwołanie do przodka danego węzła przy pomocy wskaźnika $p$ było zamienione na odwołanie do odpowiedniego elementu stosu.
Implementacja tej procedury została przedstawiona na poniższym pseudokodzie:
\begin{codebox}
\Procname{$\proc{RB-No-Parents-Insert-Fixup}(T,S,z)$}
\li	$p\gets\proc{Pop}(S)$
\li	\While $\attrib{p}{color}=\const{red}$
\li		\Do $pp\gets\proc{Pop}(S)$
\li			\If $p=\attrib{pp}{left}$
\li				\Then $y\gets\attrib{pp}{right}$
\li					\If $\attrib{y}{color}=\const{red}$
\li						\Then $\attrib{y}{color}\gets\attrib{p}{color}\gets\const{black}$
\li							$\attrib{pp}{color}\gets\const{red}$
\li							$z\gets pp$
\li							$p\gets\proc{Pop}(S)$
\li						\Else \If $z=\attrib{p}{right}$
\li							\Then $z\leftrightarrow p$
\li								$\proc{No-Parents-Left-Rotate}(T,z,pp)$
							\End
\li							$\attrib{p}{color}\gets\const{black}$
\li							$\attrib{pp}{color}\gets\const{red}$
\li							$\proc{No-Parents-Right-Rotate}(T,pp,\proc{Pop}(S))$ \label{li:no-parents-insert-fixup-left-rotate}
						\End
\li				\Else (to samo co po \kw{then} z~zamienionymi wskaźnikami \id{right} i~\id{left})
				\End
		\End
\li	$\attrib{\attrib{T}{root}}{color}\gets\const{black}$
\end{codebox}
W~każdej iteracji pętli \kw{while}, oprócz węzła $z$, potrzebujemy znać także jego ojca i~dziadka.
Węzły te są pobierane ze stosu $S$ przekazywanego do procedury i~umieszczane w~zmiennych, odpowiednio, $p$ i~\id{pp}.
Ponieważ rotacje także wykorzystują wskaźniki do ojca, to wyeliminujemy te użycia poprzez przekazanie dodatkowego parametru -- ojca rotowanego węzła.
W~wierszu \ref{li:no-parents-insert-fixup-left-rotate} powyższej procedury ojciec węzła \id{pp} jest ściągany ze stosu i~przekazywany do prawej rotacji.
Pobranie dodatkowego elementu ze stosu $S$ nie powoduje jednak problemów, bo pętla \kw{while} nie wykona więcej iteracji i~żaden element nie będzie już ściągany z~$S$.

Poniżej znajduje się operacja lewej rotacji na węźle $x$, która nie korzysta ze wskaźników na ojca.
Zamiast tego otrzymuje ona trzeci parametr, będący ojcem węzła $x$.
\begin{codebox}
\Procname{$\proc{No-Parents-Left-Rotate}(T,x,p)$}
\li	$y\gets\attrib{x}{right}$
\li	$\attrib{x}{right}\gets\attrib{y}{left}$
\li	\If $p=\attrib{T}{nil}$
\li		\Then $\attrib{T}{root}\gets y$
\li		\Else \If $x=\attrib{p}{left}$
\li			\Then $\attrib{p}{left}\gets y$
\li			\Else $\attrib{p}{right}\gets y$
			\End
		\End
\li	$\attrib{y}{left}\gets x$
\end{codebox}
Implementacja prawej rotacji nie wykorzystującej wskaźników na ojca jest analogiczna.
