\problem{Drzepce, czyli drzewa ,,treaps''} %13-4

\subproblem %13-4(a)
Dla danego zbioru węzłów $x_1$, $x_2$, \dots, $x_n$ może istnieć wiele możliwych drzew wyszukiwań binarnych zbudowanych z~tych węzłów.
Jeśli $\attrib{x_i}{key}<\attrib{x_j}{key}$, to węzeł $x_i$ może znajdować się w~lewym poddrzewie węzła $x_j$ albo $x_j$ może znajdować się w~prawym poddrzewie $x_i$.
Powiązanie z~każdym węzłem priorytetów i~utrzymywanie na ich podstawie własności kopca typu min w~drzepcu sprawia, że niejednoznaczność ta znika -- węzeł o~niższym priorytecie zajmuje w~drzepcu wyższy poziom od węzła o~wyższym priorytecie.
A~zatem, jeśli dodatkowo $\attrib{x_i}{priority}<\attrib{x_j}{priority}$, to węzeł $x_i$ jest przodkiem $x_j$, a~w~przeciwnym przypadku -- odwrotnie.
Dla każdej pary węzłów z~danego zbioru istnieje jednoznacznie wyznaczone ich wzajemne rozmieszczenie w~drzepcu, dlatego istnieje dokładnie jeden drzepiec dla tego zbioru węzłów i~powiązanych z~nimi priorytetów.

\subproblem %13-4(b)
Niech $T$ będzie drzepcem zbudowanym z~węzłów $x_1$, $x_2$, \dots, $x_n$.
Załóżmy bez utraty ogólności, że priorytety węzłów w~$T$ zostały wybrane ze zbioru $P=\{1,2,\dots,n\}$ losowo i~niezależnie od każdego węzła.
Rozważamy więc pewną permutację $\pi$ zbioru $P$, która wyznacza priorytety dla ciągu węzłów drzepca $T$, tzn.\ dla $i=1$, 2, \dots, $n$, priorytetem $x_i$ jest $\pi(i)$.
Oczywiście każda z~$n!$ permutacji zbioru $P$ jest jednakowo prawdopodobna, co oznacza, że każda permutacja kluczy węzłów, wyznaczona przez ich rosnące priorytety, jest również jednakowo prawdopodobna.
Możemy zatem potraktować drzepiec $T$ jak drzewo wyszukiwań binarnych utworzone przez wstawienie do niego węzłów o~coraz większym priorytecie, czyli, kolejno $x_{\pi^{-1}(1)}$, $x_{\pi^{-1}(2)}$, \dots, $x_{\pi^{-1}(n)}$.
Drzewo $T$ jest zatem losowo skonstruowanym drzewem wyszukiwań binarnych, które, na podstawie analizy z~podrozdziału 12.4, ma wysokość $h=O(\lg n)$.
Wynik ten, wraz z~dolnym oszacowaniem na $h$ otrzymanym w~\refExercise{B.5-4}, daje nam oczekiwaną wysokość drzepca równą $\Theta(\lg n)$.

\subproblem %13-4(c)
Procedura \proc{Treap-Insert} wstawia nowy węzeł $z$ do drzepca $T$ tak, jakby $T$ było zwykłym drzewem wyszukiwań binarnych.
Jeśli priorytet nowego węzła jest mniejszy od priorytetu jego ojca, to mamy naruszoną własność kopca typu min i~procedura przystępuje do jej przywrócenia.
Wykonuje w~tym celu odpowiednie rotacje, przenosząc dzięki temu węzeł $z$ na wyższe poziomy drzepca aż do momentu, gdy $z$ osiągnie korzeń albo gdy własność kopca między $z$ i~\attrib{z}{p} jest już spełniona.
Gdy $z$ jest lewym synem \attrib{z}{p}, to na \attrib{z}{p} wykonywana jest prawa rotacja, natomiast gdy $z$ jest prawym synem \attrib{z}{p} -- lewa rotacja.

Operacja wstawiania węzła do drzepca została przedstawiona na poniższym pseudokodzie:
\begin{codebox}
\Procname{$\proc{Treap-Insert}(T,z)$}
\li	$\proc{Tree-Insert}(T,z)$ \label{li:treap-insert-tree-insert}
\li	\While $z\ne\attrib{T}{root}$ i~$\attrib{z}{priority}<\attribb{z}{p}{priority}$
\li		\Do \If $z=\attribb{z}{p}{left}$
\li				\Then $\proc{Right-Rotate}(\attrib{z}{p})$
\li				\Else $\proc{Left-Rotate}(\attrib{z}{p})$
				\End		
		\End
\end{codebox}

\subproblem %13-4(d)
Wywołanie z~linii~\ref{li:treap-insert-tree-insert} potrzebuje czasu proporcjonalnego do wysokości $h$ drzepca $T$, a~liczba rotacji wykonywanych w~trakcie działania pętli \kw{while} nigdy nie przekracza $h$.
A~zatem oczekiwany czas działania procedury \proc{Treap-Insert} wynosi $\Theta(h)$, co na mocy faktu wykazanego w~punkcie (b) jest równe $\Theta(\lg n)$.

\subproblem %13-4(e)
\subproblem %13-4(f)
\subproblem %13-4(g)
\subproblem %13-4(h)
\subproblem %13-4(i)
\subproblem %13-4(j)
