\problem{Złączanie drzew czerwono-czarnych} %13-2

\subproblem %13-2(a)
Podczas wstawiania nowego węzła do drzewa $T$ czarna wysokość $T$ może zmienić się tylko wtedy, gdy czerwony korzeń $T$ zostaje pokolorowany na czarno.
Można więc w~procedurze \proc{RB-Insert-Fixup} bezpośrednio przed ostatnim wierszem zinkrementować wartość \attrib{T}{bh} w~przypadku, gdy $\attrib{\attrib{T}{root}}{color}=\const{red}$.

W~usuwaniu węzła wszystkie przypadki w~procedurze \proc{RB-Delete-Fixup} zachowują własność 5, o~ile przyjmiemy, że węzeł aktualnie pokazywany przez $x$ wnosi dodatkową ,,czarną jednostkę''.
Czarna wysokość drzewa $T$ może być więc zmodyfikowana tylko wtedy, gdy nadmiarowa ,,czarna jednostka'' jest usuwana z~korzenia.
Wystarczy zatem bezpośrednio przed linią 23 zmniejszyć \attrib{T}{bh} o~1, gdy $x=\attrib{T}{root}$.

Czarna wysokość korzenia drzewa $T$ to oczywiście \attrib{T}{bh}.
Jeśli dany węzeł jest czerwony, to ma tę samą czarną wysokość, co jego ojciec.
Gdy natomiast jest czarny (ale nie jest korzeniem), to jego czarna wysokość jest o~1 mniejsza od czarnej wysokości ojca.
Możemy więc wyznaczyć czarne wysokości wszystkich węzłów na ścieżce od korzenia drzewa $T$ do jego liścia w~czasie proporcjonalnym do długości tej ścieżki.

\subproblem %13-2(b)
Poniższy pseudokod realizuje opisaną operację.
\begin{codebox}
\Procname{$\proc{RB-Join-Point}(T_1,T_2)$}
\li	$y\gets\attrib{T_1}{root}$ \label{li:rb-join-point-initial-node}
\li	$b\gets\attrib{T_1}{bh}$
\li	\While $b>\attrib{T_2}{bh}$
\li		\Do \If $\attrib{y}{right}\ne\attrib{T_1}{nil}$ \label{li:rb-join-point-if-begin}
\li				\Then $z\gets\attrib{y}{right}$
\li				\Else $z\gets\attrib{y}{left}$
				\End \label{li:rb-join-point-if-end}
\li			\If $\attrib{z}{color}=\const{black}$
\li				\Then $b\gets b-1$
				\End
\li			$y\gets z$
		\End
\li	\Return $y$
\end{codebox}
Algorytm przechodzi drzewo $T_1$ od korzenia w~dół, wybierając w~pierwszej kolejności prawego syna aktualnego węzła $y$, a~jeżeli ten jest równy \attrib{T_1}{nil}, to wtedy lewego syna $y$.
Dzięki temu odwiedzane są węzły o~największym możliwym kluczu na danej czarnej wysokości w~drzewie $T_1$.
Algorytm kończy działanie, gdy czarna wysokość $b$ węzła $y$, wyznaczona na podstawie obserwacji z~punktu~(a), zrówna się z~wartością \attrib{T_2}{bh}.
Gdy to się wydarzy, węzeł $y$ jest czarny i~następuje jego zwrócenie.

Algorytm może odwiedzić wszystkie węzły na pewnej ścieżce od korzenia do liścia.
Ponieważ $T_1$ jest drzewem czerwono-czarnym o~co najwyżej $n$ węzłach, to czas działania algorytmu można ograniczyć od góry przez $O(\lg n)$.

\subproblem %13-2(c)
Na podstawie założenia, klucz korzenia $y$ drzewa $T_y$, będącego poddrzewem $T_1$, jest mniejszy lub równy od \attrib{x}{key}.
Można zatem, bez naruszenia własności drzewa wyszukiwań binarnych, umieścić węzeł $x$ między $y$ i~ojcem $y$, czyniąc $T_1$ lewym poddrzewem $x$, a~$T_2$ -- jego prawym poddrzewem.

\subproblem %13-2(d)
Jeżeli pokolorujemy węzeł $x$ na czerwono, to czarna wysokość ojca $x$ (o~ile $x\ne\attrib{T}{root}$) nie zmieni się i~czerwono-czarne własności 1, 3 i~5 będą spełnione.
W~przypadku gdy $x=\attrib{T}{root}$, to naruszona może być czerwono-czarna własność 2, a~jeśli $x\ne\attrib{T}{root}$, to węzeł \attrib{x}{p} także może być czerwony, co powoduje naruszenie własności 4.
Z~identyczną sytuacją mieliśmy do czynienia podczas wstawiania węzła do drzewa czerwono-czarnego przy pomocy procedury \proc{RB-Insert}.
Możemy więc posłużyć się pomocniczą procedurą, wywołując $\proc{RB-Insert-Fixup}(T,x)$, co przywróci naruszone własności 2 i~4 w~drzewie $T$ w~czasie $O(\lg n)$.

\subproblem %13-2(e)
W~sytuacji symetrycznej algorytm z~punktu (b) będzie wyszukiwał w~drzewie $T_2$ czarny węzeł $y$ o~możliwie najmniejszym kluczu spośród węzłów o~czarnej wysokości \attrib{T_1}{bh}, preferując lewych synów w~poruszaniu się po ścieżce w~dół drzewa.
Można to zrealizować, modyfikując pseudokod \proc{RB-Join-Point} poprzez zamianę $T_1$ z~$T_2$ w~liniach \doubledash{\ref{li:rb-join-point-initial-node}}{\ref{li:rb-join-point-if-begin}} oraz zamianę pól \id{left} i~\id{right} w~liniach \doubledash{\ref{li:rb-join-point-if-begin}}{\ref{li:rb-join-point-if-end}}.
Węzeł $x$ można następnie umieścić w~drzewie $T_2$ jako nowy ojciec węzła $y$, który teraz staje się prawym synem $x$, a~drzewo $T_1$ uczynić lewym poddrzewem $x$.
Pokolorowanie $x$ na czerwono i~przywrócenie własności drzewa czerwono-czarnego w~wynikowym drzewie $T$ odbywa się identycznie jak w~punkcie (d).

\subproblem %13-2(f)
Pseudokod procedury \proc{RB-Join} znajduje się poniżej.
\begin{codebox}
\Procname{$\proc{RB-Join}(T_1,x,T_2)$}
\li	\If $\attrib{T_1}{bh}\ge\attrib{T_2}{bh}$
\li		\Then $y\gets\proc{RB-Join-Point}(T_1,T_2)$
\li			$\attrib{x}{left}\gets y$
\li			$\attrib{x}{p}\gets\attrib{y}{p}$
\li			\If $\attrib{y}{p}=\attrib{T_1}{nil}$
\li				\Then $\attrib{T}{root}\gets x$
\li				\Else $\attrib{T}{root}\gets\attrib{T_1}{root}$
				\End
\li			\If $y\ne\attrib{T_1}{nil}$
\li				\Then $\attrib{y}{p}\gets x$
				\End
\li			$\attrib{x}{right}\gets\attrib{T_2}{root}$
\li			\If $\attrib{T_2}{root}\ne\attrib{T_2}{nil}$
\li				\Then $\attrib{\attrib{T_2}{root}}{p}\gets x$
				\End
\li			$\attrib{x}{color}\gets\const{red}$
\li			$\proc{RB-Insert-Fixup}(T,x)$
\li		\Else (to samo co po \kw{then} odwrócone symetrycznie) \label{li:rb-join-symmetric-case}
		\End
\end{codebox}
W~wierszu~\ref{li:rb-join-symmetric-case} wykonywane są operacje dla przypadku, gdy $\attrib{T_1}{bh}<\attrib{T_2}{bh}$, opisane dokładnie w~części (e).

Na podstawie analizy z~poprzednich punktów wynika, że czas działania operacji złączania drzew czerwono-czarnych o~sumarycznej liczbie węzłów $n$ wynosi $O(\lg n)$.
