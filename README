I Ogólne

Jeśli należy odnieść się do podpunktu problemu lub zadania, to używamy konstrukcji "punkt~(b) z~problemu~\refProblem{7-2}".
Odnosząc się do tekstu "Wprowadzenia do algorytmów", używamy wyrazu "Podręcznik".
Przy składaniu zależności rekurencyjnych w warunkach używa się słowa "jeżeli", a nie "dla".
Opis działania algorytmu i analiza jego czasu działania powinny znaleźć się w osobnych akapitach.
Po pseudokodzie piszemy w tym samym paragrafie tylko wówczas, gdy piszemy o samym pseudokodzie (tzn. nie zaczynamy nowego wątku).
Można opuścić jawne określenie, że zmienna jest całkowitoliczbowa, o ile jest ona użyta jako indeks tablicy (np. 6-3(b)).
Jeśli wymagane jest "napisanie pseudokodu", to należy napisać pseudokod, natomiast jeśli w polecenie mówi "opisz/podaj algorytm", to można zamieścić opis algorytmu lub pseudokod, mając na uwadze prostotę, ścisłość i przejrzystość przekazu.
Jeśli występuje błąd w tłumaczeniu lub oryginale treści zadania, to opisujemy ten fakt, używając notki (\note) przed treścią rozwiązania. Unikamy określenia "w tłumaczeniu", zakładając, że domyślnie komentujemy problemy tylko z tłumaczenia. Jeśli błąd występuje także w oryginale i nie został on poprawiony w erracie, to zwracamy także na to uwagę.
W dowodach niezmienników pętli w zakończeniach nie należy dowodzić niezmiennika po zakończeniu pętli ale na podstawie jego prawdziwości podczas działania pętli stwierdzić co się dzieje po zakończeniu pętli.
Jeśli korzystamy ze wskazówki podanej w treści zadania, to należy o tym napisać, ale korzystanie ze wskazówek nie jest konieczne.
Jeśli definiujemy jakieś pojęcie, to stosujemy pogrubienie, jak to jest w Podręczniku (np. 6.5-4).
Wyrażenia regularne do wyszukiwania sierot i numerów wzorów: [ (	][a-zA-Z] , ^[a-zA-Z] , [^%0-9:{][123]?[0-9ABC]\.[0-9].


II LaTeX

Używamy następującego sekcjonowania wewnątrz plików ch??.tex i app?.tex:
	\chapter{Nazwa}
		\subchapter{Nazwa}
			\exercise %numer
				[\subexercise %numer]
	\problems
	\problem{Nazwa} %numer
		[\subproblem %numer]
	\endinput
Stosujemy tyldy po sierotach i w miejscach niełamliwych.
Używamy polskich cudzysłowów, czyli ,,tekst''.
Jeśli w wielowierszowych formułach jest zbyt mały odstęp między wierszami, to można go zwiększyć poprzez \\[x mm].
Jeśli w środku zdania wystąpi kropka, wykrzyknik lub pytajnik, które nie kończą tego zdania, to po tych znakach należy umieścić \  (twarda spacja).
Jeśli kropka, wykrzyknik lub pytajnik występują po dużej literze i kończą zdanie, to przed tymi znakami należy umieścić \@.
Umieszczamy \/ po tekście złożonym czcionką pochyłą, ale przed tekstem złożonym czcionką zwykłą (z wyjątkiem gdy zaczyna się on kropką lub przecinkiem).
Pamiętamy o makrach \onedash, \twodashes, \refExercise, \refProblem, \E, \Pr, \Var, \note.
Po użyciu \note na początku zadania należy użyć \noindent na początku następnego paragrafu.
W \note stosujemy tryb matematyczny nawet dla pojedynczych liczb, a \/ bezpośrednio przed trybem matematycznym.
Po \E, \Pr, \Var używa się nawiasów okrągłych.
Dla zmiennych losowych wskaźnikowych używa się \I, po czym nawiasów okrągłych.
Używamy \bigl, \bigr i pozostałych zamiast \left, \right (głównie do ułamków) (\biggl, \biggr do dużych operatorów np. \sum).
Formuły matematyczne składane są wg zasad D. Knutha w "The TeXbook".
Krotki, ciągi i tablice zapisujemy w nawiasach kątowych \langle i \rangle.
Jeśli piszemy o zbiorach, ciągach, parach itd., to przecinki są ich częścią, więc są wewnątrz trybu matematycznego, w pozostałych przypadkach, przecinki należy umieszczać poza tym trybem (wyjątkiem jest trik z opisem pod rysunkiem).
Używamy \dots zamiast \cdots i \ldots (chyba, że po obu stronach mamy znaki mnożenia, jak w 8-5(f)).
Preferujemy \text{tekst $formuła$} zamiast \text{tekst }formuła.
Wewnątrz paragrafu stosujemy zwykły tryb matematyczny, a jeśli trzeba coś wyróżnić, to displaystyle.
Formuły zapisujemy w otoczeniach equation* (\[, \]), align* lub gather* (jak w 3.1-2), a jeśli mają być dzielone, to split wewnątrz align* (jak w 3.1-8).
Jeśli formułę można zapisać w jednej linii, to staramy się to zrobić (unikamy łamania krótkich formuł między kilka linii).
Jeśli formuła nie mieści się w jednej linii, ale składa się z krótkich wyrażeń między równościami lub nierównościami, to można ją podzielić jak w 5.2-5.
W ostateczności, aby zniwelować underfull vbox, można zastosować \medskip (jak przed 4.2-4)
Używamy \bigskip tylko wówczas, gdy chcemy wyraźniej oddzielić dwa paragrafy ze względu na kontekst, a nie z powodów technicznych (jak w 3-2(f), B.3-1).
Do opisu przypadków danej sytuacji stosujemy albo środowisko itemize albo środowisko enumerate z numerowaniem itemów małymi cyframi rzymskimi w nawiasach (jak w 7.4-6).


III Matematyka

Jeśli stosujemy kwantyfikator ogólny do zmiennej całkowitej k, 1<=k<=n, to stosujemy zapis $k=1$, 2,~\dots,~$n$.
Jeśli stosujemy kwantyfikator szczegółowy do zmiennej całkowitej k, 1<=k<=n, to stosujemy zapis "pewne $k$ ze zbioru $\{1$, 2,~\dots,~$n\}$" ALBO "pewne $k$ całkowite, gdzie $1\le k\le n$".
Dla liczb rzeczywistych stosujemy przedziały w zapisane w notacji matematycznej ([a,b], (a,b], [a,b), (a,b)), natomiast dla liczb całkowitych lub naturalnych (w szczególności dla indeksów tablic) stosujemy przedziały w konwencji "informatycznej" (a\twodots b, co oznacza {a, a+1, ..., b}, dla a, b całkowitych, a <= b).
Nie mieszamy obu tych konwencji (np. [a\twodots b] -- taki zapis pojawia się w Podręczniku), chyba że ma on na celu wyznaczenie pewnej podtablicy (np. A[1\twodots n]).
Jeśli używamy zmiennej, to należy określić, czy oznacza ona liczbę całkowitą, czy z innego zbioru, chyba że jednoznacznie jest to określone np. poprzez użycie jej jako indeksu tablicy lub wskazane w treści zadania.
Potęgę pierwiastka zapisuje się, obejmując pierwiastek w nawiasy i umieszczając wykładnik na zewnątrz tego nawiasu.
Numery wyrażeń (odnośniki) zapisuje się w nawiasach okrągłych.
Jeśli kilka równań lub nierówności występuje jedno pod drugim (jak w C.5-6), to oddzielamy je przecinkami, wszak nie stanowią one jednego wzoru.
Indukcję matematyczną prowadzi się tak, aby udowodnić n-ty element ciągu, a nie (n+1)-szy.
Podstawą indukcji przy dowodzeniu oszacowania rekurencji T nie jest np. T(1), ale np. n=1.
Poziomy drzew ukorzenionych liczy się od 0.
Wszędzie gdzie tylko możliwe stosujemy zapis \Theta(1) zamiast O(1).


IV Język

Przydatna strona: http://pl.wikipedia.org/wiki/Pomoc:Powszechne_b%C5%82%C4%99dy_j%C4%99zykowe.
Obiekty matematyczne mają domyślnie rodzaj nijaki, np. "x jest mniejsze niż 3", chyba że dany obiekt matematyczny występuje ze swoim typem np. "wartość x jest mniejsza niż 3".
W odniesieniu do przedmiotów, pojęć, używamy "za pomocą", a nie "przy pomocy".
Nie stawia się przecinka przed "czy" tylko wtedy, gdy znaczy ono "lub", "albo".
Nie stawia się przecinka przed "itd." i "itp.".
Nie stawia się przecinka po rozpoczynających zdanie wyrażeniach odnoszących się do wcześniejszych wypowiedzi, takich jak "stąd", "mimo to", "dzięki temu", "w tym celu", "w ten sposób", "z tego powodu" itd.
Nie stawia się przecinka po wyrazach i wyrażeniach wprowadzających typu: "jednak", "w efekcie", "w rezultacie", "dlatego", "a zatem", "na ogół", "dodatkowo", "podobnie", "tym samym", "w szczególności", "ponadto", "na przykład", "wreszcie" itd.
Nie stawia się przecinka przed członem porównawczym wprowadzonym przez wyrazy "jak", "jakby", "jako", "niż", chyba że mają wyraźnie charakter dopowiedzenia.
Stawia się przecinek przed "jak i".
Stawia się przecinek po wyrażeniach "inaczej", "innymi słowy", "dokładniej" występujących na początku zdania.
O tym, czy przed imiesłowem przymiotnikowym ("-ący", "-ony") powinien zostać postawiony przecinek, decyduje budowa zdania i intencje autora wypowiedzi.
Przyimki "ze", "we" stosuje się przy zbitkach spółgłosek trudnych do wymówienia, np. "we wzorze", "ze sobą".
Nie ma "przebiegów" i "obiegów", tylko "iteracje" pętli.
Nie "analogiczny z" ani "analogiczny jak", ale "analogiczny do".
Partykułę "nie" z imiesłowami przymiotnikowymi (czynnym i biernym) pisze się łącznie, wyjątki: "nie większy", "nie mniejszy".
Oddziela się przecinkiem imiesłów zakończony na "-ąc", "-łszy", "-wszy" od dalszej części zdania.
W zdaniach o konstrukcji "... zarówno A, jak i B ..." orzeczenie jest w liczbie pojedynczej, chyba że A i B to rzeczowniki konkretne (zjawiska lub przedmioty rozpoznawane przez człowieka przy użyciu zmysłów).


V Pseudokody

Pamiętamy o komentarzach w pseudokodach, jeśli coś jest niejasne.
Nie numerujemy linii (\zi zamiast \li) w typowych jednowierszowych makrach, np. d-ary-Parent, d-ary-Child.
Jeśli nazwa procedury zawiera znak "'", to jest on umieszczany w trybie matematycznym poza klauzulą \proc, np. \proc{List-Search}$'$.
Słowa kluczowe error i return przerywają procedury, więc nie trzeba umieszczać \Else po \Error i \Return (chyba że bardziej elegancko wygląda z \Else jak w 2.3-5).
W pseudokodach po znaku operatora występującym po \id{} należy dać odstęp \, (jak w 2.3-5).
Etykiety w pseudokodach powinny mieć identyfikatory zaczynające się od pełnej nazwy procedury.
Jeśli wywołujemy algorytm, to nie musimy koniecznie pobierać wartości przez niego zwracanej, gdy interesują nas tylko zmiany, jakich dokonuje na argumentach.
Używamy \Else \If zamiast \ElseIf, chyba że poziom zagnieżdżenia ifów i else'ów jest większy niż 2.
Jeśli testujemy wynik funkcji logicznej, to aby sprawdzić, czy zwróciła ona true, stosujemy skrócony zapis, np. \If \proc{Stack-Empty}(S). Jeśli testujemy, czy zwróciła false, to korzystamy z zapisu jawnego: \If \proc{Stack-Empty}(S)=\const{false}.
Jeśli pewna instrukcja jest ciężka do zapisania za pomocą właściwego pseudokodu, a można ją w jasny sposób opisać językiem naturalnym, to wybieramy to ostatnie.
Występuje bug w pakiecie clrscode - począwszy od drugiej linijki po \ElseNoIf, tekst jest za bardzo wcinany. Rozwiązaniem jest:
\li	\ElseNoIf linijka_1
		\End
\li		\phantom{\kw{else}} linijka_2
\li		\phantom{\kw{else}} linijka_3
...


VI Rysunki i tabele

Rysunki i tabele umieszczamy wewnątrz otoczenia center, które jest wewnątrz figure[ht]. Czasami rysunki kumulują się na końcu rozdziału, aby temu zapobiec, można zastosować figure[ht!].
Rysunki komórek tablic powinny mieć wymiary takie jak w fig02.1 albo w fig08.1, jeśli potrzebne są mniejsze.
W rysunkach dla indeksów tablic itp. używamy decimal (i) infont "cmr8", w innych przypadkach defaultfont := "cmr8"; lub \fontsize{8}{10}\selectfont.
Rysunki kilkuczęściowe oznaczamy literkami (a), (b), ... poprzez umieszczenie w źródle danego rysunku label(btex \fontsize{9}{11}\selectfont{\sffamily\bfseries (a)} etex, (x, y)); gdzie (x, y) jest miejscem, w którym będzie znajdować się literka.
Stosujemy jednolite kolory szarości w rysunkach (lightgray = .8white (domyślny, jeśli potrzebny tylko jeden odcień szarości), medgray = .6white, darkgray = .4white).
Jeśli jest problem ze zmieszczeniem opisu pod rysunkiem z tablicą, ciągiem lub krotką, to można zastosować trik z opuszczeniem trybu matematycznego i zastosowaniem ujemnych odstępów jak w 6.2-1.
Rysunki, które nie są wzorowane na podobnych z Podręcznika, są opisywane bardzo krótko, aby nie powtarzać objaśnień konwencji z rysunku z Podręcznika, natomiast pozostałe rysunki są opisywane nieco bardziej obszernie.
Pilnujemy, aby w opisie pod rysunkiem nie było sytuacji, w której odniesienie do części rysunku (np. (c)) znalazło się na końcu linii.


VII Implementacje

Implementujemy i testujemy każdy algorytm zapisany w pseudokodzie w Podręczniku, chyba że jest celowo błędny (w zadaniach na sprawdzenie poprawności tego algorytmu, np. Permute-With-All), niekompletny (uzupełnienie tego algorytmu stanowi polecenie jednego z zadań, np. Enqueue - wówczas implementujemy kompletną wersję) lub nie rozwiązuje realnego problemu i służy jako ilustracja pewnej metody (np. Hire-Assistant).
Implementujemy i testujemy każdy algorytm zapisany w pseudokodzie w rozwiązaniach.
Implementujemy i testujemy każdy algorytm, który jest opisany słownie w rozwiązaniach, o ile polecenie zadania/problemu mówi wyraźnie "podaj/zaprojektuj/skonstruuj algorytm/procedurę/implementację" itp.
Polecenie służące do testowania większości algorytmów:
	for ((n=1; n<=1000; n++)); do ./algotest $n; done | grep '^OK$' | wc -l
Można pominąć testowanie, jeśli poprawność algorytmu jest oczywista (np. Extract-Max) lub nie ma innego szybkiego i naturalnego sposobu testowania poprawności oprócz powtórzenia operacji z kodu testowanej procedury (np. List-Insert).
Procedury pomocnicze, np. Partition, testujemy poprzez uruchomienie testów dla algorytmów wywołujących te procedury, np. Quicksort -- czasami trzeba tymczasowo zmienić implementację głównego algorytmu, aby wykorzystywał nową wersję procedury pomocniczej.
Algorytmy implementujemy w podejściu proceduralnym, ale wykorzystując struktury danych z najważniejszymi operacjami (np. struktura array implementuje tablicę i zawiera m.in. operator dostępu do komórki [] lub operację sprawdzania czy jest posortowana), które umieszczamy w plikach util.h i util.cpp.
Implementacje algorytmów umieszczamy w plikach ch??.h i ch??.cpp, a testy -- w plikach ch??Test.h i ch??Test.cpp.
Jako nazw procedur używamy nazw ich pseudokodów, opuszczając myślniki, a znaki ' zamieniając na liczby (np. ' zamienimy na 2, '' - na 3 itd.), a w przypadku, gdy dla danego algorytmu nie podano pseudokodu, najbardziej odpowiednią nazwę wymyślamy.
Staramy się, aby kod implementujący algorytm był jak najbardziej zbliżony do jego pseudokodu/opisu.
