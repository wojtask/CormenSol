\problem{Sortowanie największych $i$ elementów} %9-1

\subproblem %9-1(a)
Liczby można posortować algorytmem sortowania przez scalanie, który w~najgorszym przypadku potrzebuje czasu $\Theta(n\lg n)$.
Wypisanie $i$ największych liczb otrzymanej tablicy, poprzez zwyczajne przeglądnięcie jej $i$ ostatnich elementów, zajmuje czas $\Theta(i)$.
Całkowity czas algorytmu w~przypadku pesymistycznym wynosi zatem $\Theta(n\lg n+i)$.

\subproblem %9-1(b)
Zbudowanie kopca typu max dla kolejki priorytetowej algorytmem \proc{Build-Max-Heap} wymaga czasu $\Theta(n)$.
Wykonanie kolejno $i$ operacji \proc{Extract-Max} na kopcu o~co najwyżej $n$ elementach wymaga czasu $i\cdot O(\lg n)=O(i\lg n)$.
Z~kolei połowa tych operacji będzie wykonywana na kopcu o~co najmniej $n/2$ elementach.
Zajmą one czas $(i/2)\cdot\Omega(\lg(n/2))=\Omega(i\lg n)$ w~najgorszym przypadku.
Stąd mamy, że wszystkie operacje ekstrakcji zostaną wykonane w~czasie $\Theta(i\lg n)$ w~przypadku pesymistycznym, a~zatem całkowitym czasem algorytmu jest $\Theta(n+i\lg n)$.

\subproblem %9-1(c)
Aby osiągnąć najlepszy czas w~przypadku pesymistycznym, użyjemy procedury \proc{Select} do znalezienia $i$\nbhyphen tej statystyki pozycyjnej.
Jednocześnie tablica elementów wejściowych zostanie podzielona względem tejże statystyki.
Sortowanie $i$ największych liczb można wykonać algorytmem sortowania przez scalanie, które w~najgorszym przypadku zajmuje czas $\Theta(i\lg i)$.
Stąd całkowity czas działania algorytmu wynosi $\Theta(n+i\lg i)$, co czyni go najbardziej efektywnym spośród wszystkich rozważanych algorytmów w~niniejszym problemie.
