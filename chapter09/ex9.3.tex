\subchapter{Wybór w~pesymistycznym czasie liniowym}
\note{Ponieważ nie jest to sprecyzowane w~Podręczniku, w~rozwiązaniach przyjmiemy, że parametry procedury \proc{Select} odpowiadają parametrom procedury \proc{Randomized-Select}, czyli są nimi kolejno: tablica reprezentująca zbiór wejściowy, początkowy i~końcowy indeks przeszukiwanego fragmentu tej tablicy oraz numer szukanej statystyki pozycyjnej.}
\bignegskip

\exercise %9.3-1
Dokonajmy analizy algorytmu \proc{Select} w~przypadku, gdy elementy są dzielone na grupy 7\nbhyphen elementowe.
Wówczas w~co najmniej połowie spośród $\lceil n/7\rceil$ grup są po 4 elementy większe od $x$, oprócz jednej grupy o~mniej niż 7 elementach, jeśli $n$ nie jest wielokrotnością 7, i~jednej grupy zawierającej sam element $x$.
Odliczając te dwie grupy, dostajemy, że liczba elementów większych od $x$ wynosi co najmniej
\[
	4\biggl(\biggl\lceil\frac{1}{2}\Bigl\lceil\frac{n}{7}\Bigr\rceil\biggr\rceil-2\biggr) \ge \frac{2n}{7}-8.
\]
Podobnie wykazuje się, że liczba elementów mniejszych od $x$ wynosi co najmniej $2n/7-8$.
Stąd w~kroku 5 algorytm wywoła się rekurencyjnie dla co najwyżej $5n/7+8$ elementów.

Znajdziemy zależność rekurencyjną $T(n)$ opisującą czas działania tego algorytmu w~przypadku pesymistycznym.
Tak jak w~oryginalnej wersji kroki 1, 2 i~4 zajmują czas $O(n)$.
Krok 3 zajmuje czas $T(\lceil n/7\rceil)$, a~krok 5 -- co najwyżej czas $T(5n/7+8)$, przy założeniu, że $T$ jest funkcją niemalejącą.
Rekurencja przyjmuje więc postać
\[
	T(n) = \begin{cases}
		O(1), & \text{jeśli $n<d$}, \\
		T(\lceil n/7\rceil)+T(5n/7+8)+O(n), & \text{jeśli $n\ge d$},
	\end{cases}
\]
gdzie $d>0$ jest pewną stałą, którą wyznaczymy później.

Wykażemy metodą podstawiania, że $T(n)=O(n)$.
Zachodzi oczywiście $T(n)\le cn$ dla pewnej stałej $c>0$ oraz wszystkich $n<d$.
Załóżmy teraz, że $n\ge d$ i~że $T(k)\le ck$ dla pewnej stałej $c>0$ i~wszystkich $k<n$.
Dla pewnej stałej $a>0$ zachodzi wówczas
\begin{align*}
	T(n) &\le c\lceil n/7\rceil+c(5n/7+8)+an \\
	&\le cn/7+c+5cn/7+8c+an \\
	&= 6cn/7+9c+an \\
	&= cn+(-cn/7+9c+an) \\
	&\le cn,
\end{align*}
o~ile składnik $-cn/7+9c+an$ jest niedodatni.
Dla $n>63$ warunek ten jest spełniony, kiedy $c\ge7a(n/(n-63))$.
Jeśli z~kolei $n\ge126$, to $n/(n-63)\le2$ i~wtedy musi być $c\ge14a$.
Można zatem przyjąć $d=126$, co kończy dowód.

Pokażemy teraz, że jeśli podział będzie dokonywany na grupy 3\nbhyphen elementowe, to czas działania tak zmodyfikowanego algorytmu \proc{Select} będzie wyższy od liniowego.
W~takim podziale w~co najmniej połowie z~$\lceil n/3\rceil$ grup są po 2 elementy większe (mniejsze) od $x$, oprócz ewentualnie jednej niepełnej grupy i~jednej grupy zawierającej sam element $x$.
Liczba elementów większych (mniejszych) od $x$ wynosi zatem co najmniej
\[
	2\biggl(\biggl\lceil\frac{1}{2}\Bigl\lceil\frac{n}{3}\Bigr\rceil\biggr\rceil-2\biggr) \ge \frac{n}{3}-4.
\]
Prowadzi to do następującej rekurencji na czas działania algorytmu w~najgorszym przypadku:
\[
	T(n) = \begin{cases}
		O(1), & \text{jeśli $n<d$}, \\
		T(\lceil n/3\rceil)+T(2n/3+4)+O(n), & \text{jeśli $n\ge d$},
	\end{cases}
\]
gdzie $d>0$ jest pewną stałą.

Użyjemy metody podstawiania do pokazania, że $T(n)=\omega(n)$, a~dokładniej, że dla dowolnej stałej $c>0$ i~odpowiednio dużych $n$ zachodzi $T(n)>cn$.
Ustalmy $c$.
Załóżmy, że istnieje stała $n_0\ge d$ taka, że dla wszystkich $n\ge n_0$ prawdziwe są nierówności
\[
	T(\lceil n/3\rceil) > c\lceil n/3\rceil \quad\text{oraz}\quad T(2n/3+4) > c(2n/3+4).
\]
Dla $n\ge n_0$ mamy:
\[
	T(n) > c\lceil n/3\rceil+c(2n/3+4) \ge cn/3+2cn/3+4c = cn+4c > cn.
\]

\exercise %9.3-2
Z~analizy algorytmu \proc{Select} wynika, że zarówno liczba elementów większych od $x$, jak i~liczba elementów mniejszych od $x$, wynosi co najmniej $3n/10-6$.
Gdy $n\ge140$, to
\[
	\frac{3n}{10}-6 = \frac{n}{4}+\frac{n}{20}-6 \ge \frac{n}{4}+\frac{140}{20}-6 = \frac{n}{4}+1 \ge \Bigl\lceil\frac{n}{4}\Bigr\rceil.
\]

\exercise %9.3-3
\note{W~rozwiązaniu przyjmujemy założenie, że elementy tablicy wejściowej są parami różne.}

\noindent W~algorytmie quicksort zamiast użycia procedury \proc{Partition} do podziału tablicy wejściowej wykorzystamy algorytm \proc{Select} do odszukania mediany elementów wejściowych.
Dzięki temu wykonywane będą najbardziej zrównoważone podziały.
Pesymistyczny czas algorytmu quicksort po takiej modyfikacji sprowadzi się do rekurencji $T(n)=2T(\lfloor n/2\rfloor)+O(n)$, której rozwiązaniem jest $T(n)=O(n\lg n)$.

\exercise %9.3-4
Jedynym źródłem informacji o~elementach we wspomnianym algorytmie wyznaczającym $i$\nbhyphen tą najmniejszą wartość są porównania.
Ponadto tablica wejściowa zawierająca te elementy nie jest modyfikowana -- po zakończeniu działania algorytmu ma ona identyczną zawartość jak na początku.
Zakładamy, że wynik każdego porównania liczb (tzn.\ ustalenie relacji $\le$ albo $>$) jest zapamiętywany, więc przy następnej próbie sprawdzenia tych samych liczb wystarczy odczytać wynik z~pamięci.
W~związku z~tym pozostaje nam udowodnić, że porównania, które przeprowadzono i~zapamiętano podczas działania algorytmu, aby jednoznacznie stwierdzić, który element jest $i$\nbhyphen tym najmniejszym, są wystarczające, by jednoznacznie wskazać $i-1$ najmniejszych oraz $n-i$ największych elementów.

Oznaczmy przez $u$ element zwrócony przez algorytm.
W~rozwiązaniu będziemy korzystać z~przechodniości relacji porządku liczb.
Jeśli algorytm stwierdził, że $x\le y$ oraz $y\le z$, to wnioskujemy, że $x\le z$.
Wykażemy, że dzięki tej obserwacji możemy uzyskać informacje o~wzajemnym porządku w~każdej parze elementów ze zbioru wejściowego.
Załóżmy nie-wprost, że istnieje para $\langle x,y\rangle$, przy czym nie potrafimy stwierdzić, czy $x\le y$, czy $x>y$.
Wówczas nie potrafimy także wskazać relacji między $x$ i~każdym elementem, z~którym jesteśmy w~stanie porównać $y$, i~na odwrót.
W~szczególności istnieje element $v$, którego relacja z~$u$ nie jest nam znana.
Ale to leży w~sprzeczności z~faktem, że $u$ zostało jednoznacznie wskazane jako $i$\nbhyphen ty najmniejszy ze zbioru wejściowego -- $v$ może bowiem leżeć po jednej albo po drugiej stronie $u$, a~to prowadzi do niejednoznaczności przy określaniu pozycji $u$ w~zbiorze wejściowym.

Mając informacje na temat każdej pary, możemy przejrzeć wyniki porównań elementu $u$ z~każdym innym i~na tej podstawie klasyfikować elementy do jednego z~dwóch zbiorów wynikowych.

\exercise %9.3-5
Zmodyfikujemy procedurę \proc{Randomized-Select}, dokonując zmiany w~wierszu 3.
Zamiast wywoływać \proc{Randomized-Partition}, znajdziemy medianę $x$ elementów z~tablicy wejściowej za pomocą danej ,,czarnej skrzynki'', po czym podzielimy tablicę względem $x$.
W~każdym wywołaniu rekurencyjnym będzie wówczas dokonywany najbardziej zrównoważony podział, więc czas działania algorytmu wyboru w~przypadku pesymistycznym przyjmie postać $T(n)=T(\lfloor n/2\rfloor)+O(n)$.
Rozwiązaniem tej rekurencji jest $T(n)=O(n)$.

\exercise %9.3-6
Oznaczmy przez $S$ badany zbiór, a~przez $Q_k(S)$ -- zbiór jego kwantyli rzędu $k$, gdzie $1\le k\le|S|+1$.
Zbiór kwantyli nie jest jednoznacznie zdefiniowany, opiszemy jednak jeden z~poprawnych sposobów jego konstrukcji.
Oczywiście zbiór kwantyli rzędu $k=1$ jest pusty.
Jeśli $k$ jest parzyste, to w~skład zbioru kwantyli rzędu $k$ wchodzi mediana $m$ zbioru $S$ oraz kwantyle rzędu $k/2$ zbiorów $\{\,x\in S:x<m\,\}$ i~$\{\,x\in S:x>m\,\}$.
W~przypadku, gdy $k$ jest liczbą nieparzystą większą od 1, a~$m_1$, $m_2$ kwantylami rzędu $k$ najbliższymi mediany $m$, to zbiór kwantyli rzędu $k$, oprócz $m_1$ i~$m_2$, zawiera także kwantyle rzędu $(k-1)/2$ zbiorów $\{\,x\in S:x<m_1\,\}$ i~$\{\,x\in S:x>m_2\,\}$.

Zbiór $S$ reprezentujemy jako tablicę $A$ parami różnych elementów.
Na podstawie powyższego opisu otrzymujemy następujący algorytm oparty o~metodę ,,dziel i~zwyciężaj'':
\begin{codebox}
\Procname{$\proc{Quantiles}(A,p,r,k)$}
\li	\If $k=1$
\li		\Then \Return $\emptyset$
		\End
\li	$n\gets r-p+1$
\li	$q_1\gets p+\lfloor\lfloor k/2\rfloor(n/k)\rfloor$ \>\>\>\>\>\>\Comment pozycje zajmowane przez $\lfloor k/2\rfloor$\nbhyphen ty i~$\lceil k/2\rceil$\nbhyphen ty kwantyl rzędu $k$
\li	$q_2\gets p+\lfloor\lceil k/2\rceil(n/k)\rfloor$ \>\>\>\>\>\>\>podtablicy $A[p\twodots r]$, gdyby została ona uporządkowana
\li	$\proc{Select}(A,p,r,q_1-p+1)$
\li	\If $q_1\ne q_2$
\li		\Then $\proc{Select}(A,q_1+1,r,q_2-q_1)$ \label{li:quantiles-second-select}
		\End
\li	$L\gets\proc{Quantiles}(A,p,q_1-1,\lfloor k/2\rfloor)$
\li	$R\gets\proc{Quantiles}(A,q_2+1,r,\lfloor k/2\rfloor)$
\li	\Return $L\cup\{A[q_1],A[q_2]\}\cup R$
\end{codebox}
Aby wyznaczyć $Q_k(S)$, należy wywołać $\proc{Quantiles}(A,1,n,k)$, gdzie $n=|S|$.

W~pseudokodzie nie rozdzielamy przypadków explicite ze względu na parzystość $k$.
Po wyznaczeniu długości przetwarzanego fragmentu $A[p\twodots r]$ obliczane są pozycje $q_1$ i~$q_2$ zajmowane przez kwantyle $m_1$ i~$m_2$ (jeśli $k$ jest nieparzyste) lub medianę $m$ (jeśli $k$ jest parzyste -- wówczas $q_1=q_2$), gdyby uporządkować podtablicę $A[p\twodots r]$.
Następnie korzystamy z~algorytmu \proc{Select}, aby podzielić tę podtablicę względem elementu $m_1$ (lub $m$ dla parzystego $k$).
Jeśli $k$ jest nieparzyste (czyli $q_1\ne q_2$), to w~wierszu \ref{li:quantiles-second-select} fragment tablicy $A$ zawierający elementy większe niż $m_1$ dzielimy względem $m_2$.
W~tym momencie fragment $A[p\twodots q_1-1]$ składa się z~elementów mniejszych niż $A[q_1]=m_1$, a~fragment $A[q_2+1\twodots r]$ z~elementów większych niż $A[q_2]=m_2$.
Teraz wystarczy znaleźć kwantyle rzędu $\lfloor k/2\rfloor$ w~obu tych fragmentach i~zwrócić wynikowy zbiór.

Nierekurencyjna część algorytmu zajmuje czas $O(n)$, zatem rekursja opisująca pesymistyczny czas jego działania przyjmuje postać $T(n,k)=2T(\lfloor n/2\rfloor,\lfloor k/2\rfloor)+O(n)$.
Jej rozwiązaniem jest $T(n,k)=O(n\lg k)$, o~czym można się przekonać, stosując na przykład metodę drzewa rekursji.

\exercise %9.3-7
Liczby najbliższe medianie zbioru $S$ można zdefiniować dwa sposoby.
Są to albo ,,sąsiedzi'' mediany otaczający ją równolicznie po obu stronach w~uporządkowanym zbiorze, albo liczby najbliższe w~sensie wartości bezwzględnej.
Ponieważ treść zadania nie definiuje pojęcia ,,bliskości'', a~obydwie podane definicje są równie racjonalne, to podamy algorytmy rozwiązujące ten problem z~zastosowaniem każdej z~tych definicji.
Jak się okaże, w~obu przypadkach istnieje algorytm o~złożoności $O(n)$.

W~pierwszej wersji definicji $k$ najbliższymi liczbami medianie zbioru $S$ są elementy oddalone od mediany o~nie więcej niż około $(k-1)/2$ pozycji, gdybyśmy ustawili elementy $S$ w~kolejności rosnącej.
Znając więc ich pozycje w~uporządkowanym zbiorze, możemy je wyznaczyć za pomocą odpowiednich wywołań algorytmu \proc{Select}.
Następnie wystarczy przeglądnąć elementy zbioru $S$ i~zwrócić te, które znajdują się pomiędzy wyznaczonymi statystykami pozycyjnymi.

Poniższy pseudokod przyjmuje na wejściu $n$\nbhyphen elementową tablicę $A$ zawierającą elementy zbioru $S$ oraz liczbę $k$ i~zwraca $k$\nbhyphen elementowy zbiór $N$ ,,sąsiadów'' mediany według powyższego opisu.
\begin{codebox}
\Procname{$\proc{Median-Neighbors}(A,k)$}
\li	$n\gets\attrib{A}{length}$
\li	$m\gets\lfloor(n+1)/2\rfloor$
\li	$\id{leftmost}\gets\proc{Select}(A,1,n,m-\lfloor(k-1)/2\rfloor)$
\li	$\id{rightmost}\gets\proc{Select}(A,1,n,m+\lceil(k-1)/2\rceil)$
\li	$N\gets\emptyset$
\li	\For $i=1$ \To $n$
\li		\Do \If $\id{leftmost}\le A[i]\le\id{rightmost}$
\li				\Then $N\gets N\cup\{A[i]\}$
				\End
		\End
\li	\Return $N$
\end{codebox}
Zakładamy, że operacje inicjalizacji zbioru oraz dodania do niego nowego elementu zajmują czas stały, natomiast zarówno pobieranie jego rozmiaru, jak i~usuwanie z~niego pojedynczego elementu, odbywa się w~czasie co najwyżej proporcjonalnym do rozmiaru tego zbioru.
Założenia te można łatwo spełnić, implementując zbiór $N$ np.\ jako listę dwukierunkową (patrz podrozdział 10.2).
Wówczas czas działania powyższego algorytmu wynosi $O(n)$.

Jeśli z~kolei będziemy stosować wartość bezwzględną do określenia bliskości między elementami zbioru $S$, to wyznaczenie $k$ liczb najbliższych medianie w~takim rozumieniu odbywa się następująco.
Wyznaczymy medianę $x$ zbioru $S$, a~następnie obliczymy odległość każdego elementu z~$S$ od $x$, czyli wartość bezwzględną z~ich różnicy.
Problem sprowadza się w~tym momencie do znalezienia $k$ najmniejszych odległości, co można zrealizować, szukając wśród nich $k$\nbhyphen tej statystyki pozycyjnej $y$, a~następnie zwracając elementy odległe od $x$ o~nie więcej niż $y$.

Pojawiają się jednak dwie subtelności.
O~ile elementy wejściowe z~założenia są parami różne, to odległości od mediany mogą się powtarzać -- dokładniej, każda odległość może występować w~co najwyżej dwóch egzemplarzach.
Analiza czasu działania algorytmu \proc{Select} przeprowadzona w~Podręczniku pozostaje jednak prawdziwa, gdy rozszerzymy ją na przypadek powtarzających się elementów w~tablicy wejściowej, dlatego oszacowanie na czas działania tego algorytmu nie zmienia się.
Może się także zdarzyć, że zbiór elementów o~odległościach nieprzekraczających $y$ będzie mieć $k+1$ elementów.
Jest tak wówczas, gdy wśród wyznaczonych odległości są dwie kopie $y$.
Przed zwróceniem wynikowego zbioru wystarczy więc usunąć z~niego element $x+y$ albo $x-y$.

Poniższy algorytm stanowi implementację opisanego podejścia i~przy założeniu efektywnej implementacji na zbiorach działa w~czasie $O(n)$.
\begin{codebox}
\Procname{$\proc{Median-Nearest}(A,k)$}
\li	$n\gets\attrib{A}{length}$
\li	$x\gets\proc{Select}(A,1,n,\lfloor(n+1)/2\rfloor)$
\li	\For $i\gets1$ \To $n$
\li		\Do $\id{dist}[i]\gets|A[i]-x|$
		\End
\li	$y\gets\proc{Select}(\id{dist},1,n,k)$
\li	$N\gets\emptyset$
\li	\For $i\gets1$ \To $n$
\li		\Do \If $|A[i]-x|\le y$
\li				\Then $N\gets N\cup\{A[i]\}$
				\End
		\End
\li	\If $|N|=k+1$
\li		\Then $N\gets N\setminus\{x+y\}$
		\End
\li	\Return $N$
\end{codebox}

\exercise %9.3-8
Niech $m_X$ będzie medianą (dolną) elementów z~tablicy $X$ i~niech $m_Y$ będzie medianą (dolną) elementów z~tablicy $Y$.
Jeśli $m_X=m_Y$, to wśród wszystkich $2n$ elementów obu tablic co najmniej $n$ jest większych (lub równych) od obu median i~co najmniej $n$ jest od nich mniejszych (lub równych).
Wartość $m_X$ jest więc szukaną medianą wszystkich $2n$ liczb.
Załóżmy teraz, że $n>1$ i, bez straty ogólności, że $m_X<m_Y$.
Odrzucając teraz około $n/2$ elementów $X$ na lewo od $m_X$ i~około $n/2$ elementów $Y$ na prawo od $m_Y$, sprowadzamy problem do podproblemu mniejszego o~około połowę, ponieważ wiadomo, że poszukiwana mediana znajduje się wśród pozostawionych elementów.
Ponadto, jeśli $n$ jest parzyste, to element $m_X$ także może zostać odrzucony, bo na pewno nie jest szukaną medianą.
Do podproblemu trafią zatem pozostawione fragmenty tablic $X$ i~$Y$ o~rozmiarach $\lceil n/2\rceil$ każdy.

Podamy rekurencyjny algorytm rozwiązujący zadany problem.
Gdy $n=1$, to algorytm zwróci mniejszy z~dwóch wejściowych elementów (wynikiem jest mediana dolna).
W~przeciwnym przypadku wyznaczane są indeksy median dolnych i~górnych obu tablic, które dzięki uporządkowaniu obu tablic, jesteśmy w~stanie wyznaczyć natychmiast, po czym algorytm wywołuje się rekurencyjnie zgodnie z~powyższym opisem.
Aby odnaleźć wspólną medianę $2n$ elementów z~tablic $X[1\twodots n]$ i~$Y[1\twodots n]$, należy wywołać $\proc{Joint-Median}(X,1,n,Y,1,n)$.
\begin{codebox}
\Procname{$\proc{Joint-Median}(X,p_X,r_X,Y,p_Y,r_Y)$}
\li	\If $p_X=r_X$
\li		\Then \Return $\min(X[p_X],Y[p_Y])$
		\End
\li	$q_X\gets\lfloor(p_X+r_X)/2\rfloor$ \>\>\>\>\>\>\Comment indeks mediany dolnej podtablicy $X[p_X\twodots r_X]$
\li	$q_X'\gets\lceil(p_X+r_X)/2\rceil$ \>\>\>\>\>\>\Comment indeks mediany górnej podtablicy $X[p_X\twodots r_X]$
\li	$q_Y\gets\lfloor(p_Y+r_Y)/2\rfloor$ \>\>\>\>\>\>\Comment indeks mediany dolnej podtablicy $Y[p_Y\twodots r_Y]$
\li	$q_Y'\gets\lceil(p_Y+r_Y)/2\rceil$ \>\>\>\>\>\>\Comment indeks mediany górnej podtablicy $Y[p_Y\twodots r_Y]$
\li	\If $X[q_X]=Y[q_Y]$
\li		\Then \Return $X[q_X]$
		\End
\li	\If $X[q_X]<Y[q_Y]$
\li		\Then \Return $\proc{Joint-Median}(X,q_X',r_X,Y,p_Y,q_Y)$
\li		\Else \Return $\proc{Joint-Median}(X,p_X,q_X,Y,q_Y',r_Y)$
		\End
\end{codebox}

Pesymistyczny czas działania algorytmu opisuje rekurencja $T(n)=T(\lceil n/2\rceil)+\Theta(1)$, gdzie $n=r_X-p_X+1$.
Jej rozwiązaniem jest oczywiście $T(n)=O(\lg n)$.

\exercise %9.3-9
Oznaczmy przez $y_1$ i~$y_2$, odpowiednio, medianę dolną i~górną współrzędnych $y$ wszystkich wież.
Umieścimy główny rurociąg na współrzędnej $y$ równej $y_r$ takiej, że $y_1\le y_r\le y_2$ i~zbadamy, jak będzie zmieniać się suma długości odnóg północ\nbhyphen południe $s$, gdy będziemy zmieniać jego położenie.

Wybierzmy $y_r'$, spełniające nierówności $y_1\le y_r'\le y_2$, na współrzędną $y$ nowego położenia głównego rurociągu.
Niech $d=|y_r-y_r'|$.
Jeśli $y_1=y_2$, to $y_r'=y_r$, rozważmy więc przypadek przeciwny.
Wtedy zarówno na północ, jak i~na południe od głównego rurociągu znajduje się $n/2$ wież wiertniczych.
Do jednych zbliżyliśmy się o~odległość $d$, ale od pozostałych o~tyle samo się oddaliliśmy.
Widać stąd, że wybór dowolnego $y_r'$ znajdującego się pomiędzy medianami nie zmienia sumy długości odnóg północ\nbhyphen południe.

Niech teraz $y_r'$ będzie współrzędną $y$ głównego rurociągu taką, że $y_r'<y_1$ lub $y_r'>y_2$.
Podobnie jak poprzednio, niech $d=|y_r-y_r'|$.
Gdy $n$ jest parzyste, to po jednej stronie rurociągu mamy co najmniej $n/2+1$ wież, a~po drugiej -- co najwyżej $n/2-1$.
Stąd otrzymujemy oszacowanie na nową sumę długości odnóg:
\[
    s' \ge s+d(n/2+1)-d(n/2-1) = s+2d > s.
\]
W~przypadku, gdy $n$ jest liczbą nieparzystą, rurociąg w~nowym położeniu po jednej stronie ma co najmniej $(n+1)/2$ wież wiertniczych, a~po drugiej stronie co najwyżej $(n-1)/2$.
Nową sumę długości odnóg można więc ograniczyć od dołu:
\[
    s' \ge s+d(n+1)/2-d(n-1)/2 = s+d > s.
\]

A~zatem, niezależnie od parzystości $n$, przesunięcie rurociągu poza obszar wyznaczony przez mediany $y_1$ i~$y_2$, wiąże się z~powiększeniem sumy długości odnóg północ\nbhyphen południe -- dowolna wartość $y_r$ pomiędzy tymi medianami, łącznie z~nimi, jest optymalna.
Problem sprowadza się zatem do wyznaczenia mediany współrzędnych $y$ wież wiertniczych i~można go rozwiązać w~czasie liniowym względem $n$ mimo braku założenia o~tym, że elementy, spośród których wyznaczamy medianę, są parami różne (co zauważyliśmy w~\refExercise{9.3-7}).
