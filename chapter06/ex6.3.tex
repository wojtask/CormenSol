\subchapter{Budowanie kopca}

\exercise %6.3-1
Ilustracja działania procedury \proc{Build-Max-Heap} dla tablicy $A$ znajduje się na rys.\ \ref{fig:6.3-1}.
\begin{figure}[!ht]
	\centering \input{fig6.3-1}
	\caption{Działanie procedury \proc{Build-Max-Heap} dla tablicy $A=\langle5,3,17,10,84,19,6,22,9\rangle$.
{\sffamily\bfseries(a)} Tablica $A$ i~reprezentowane przez nią drzewo binarne przed pierwszym wywołaniem \proc{Max-Heapify} z~wiersza~3.
{\sffamily\bfseries(b)\nbendash(d)} Kopiec przed każdym kolejnym wywołaniem \proc{Max-Heapify}.
{\sffamily\bfseries(e)} Wynikowy kopiec typu max.} \label{fig:6.3-1}
\end{figure}

\exercise %6.3-2
Podczas wywołania $\proc{Max-Heapify}(A,i)$ zakładamy, że poddrzewa o~korzeniach $\proc{Left}(i)$ i~$\proc{Right}(i)$ (o~ile istnieją) są kopcami typu max.
Jeżeli podczas budowy kopca procedura \proc{Max-Heapify} byłaby wywoływana dla węzłów o~rosnących indeksach, to nie moglibyśmy zagwarantować spełnienia tego warunku.

\exercise %6.3-3
Oznaczmy przez $n_h$ liczbę węzłów kopca znajdujących się na wysokości $h$.
Udowodnimy fakt przez indukcję względem $h$.

Z~\refExercise{6.1-7} wiemy, że węzły znajdujące się w~kopcu na wysokości 0, czyli jego liście, zajmują pozycje $\lfloor n/2\rfloor+1$, $\lfloor n/2\rfloor+2$, \dots, $n$.
Jest ich zatem
\[
    n_0 = n-(\lfloor n/2\rfloor+1)+1 = n-\lfloor n/2\rfloor = \lceil n/2\rceil,
\]
a~więc przypadek bazowy indukcji jest spełniony.

Załóżmy teraz, że $h>0$ i~że $n_{h-1}\le\lceil n/2^h\rceil$.
Zauważmy, że gdy $n_{h-1}$ jest parzyste, to każdy węzeł na wysokości $h$ ma dokładnie dwóch synów, skąd $n_h=n_{h-1}/2=\lceil n_{h-1}/2\rceil$.
Z~kolei gdy $n_{h-1}$ jest nieparzyste, to jeden z~węzłów na wysokości $h$ ma jednego syna, a~pozostałe węzły po dwóch synów, zatem $n_h=(n_{h-1}-1)/2+1=\lceil n_{h-1}/2\rceil$.
Niezależnie od przypadku zachodzi więc
\[
    n_h = \lceil n_{h-1}/2\rceil \le \bigl\lceil\lceil n/2^h\rceil/2\bigr\rceil = \lceil n/2^{h+1}\rceil.
\]
