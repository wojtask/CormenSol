ROADMAP DLA 0.5:
- poprawić błędy w part I, II
- part III
- przenieść rysunki na PGF/TikZ
- Czy złożoność obliczeniową liczymy względem bitów czy względem liczb? (http://en.wikipedia.org/wiki/Bit_complexity). Może przydatne wiadomości na ten temat są we wstępie do rozdziału 31?
- Czy do symboli matematycznych odnosimy się rodzajem nijakim czy rodzaj określamy z kontekstu? >> staramy się nazywać symbol, tzn. nie pisać "to f", ale "ta funkcja f" itd. Jeśli jednak potrzebujemy opuścić nazwę symbolu, to jego rodzajem jest rodzaj jego typu (liczba, funkcja, zbiór), domyślnie rodzaj nijaki.
- uściślić konwencje stosowania ~ w sytuacjach innych niż sieroty (liczby, zakresy, zmienne, niektóre wyrażenia językowe, ...)
- jak poradzić sobie z problemem coraz większej ilości pseudokodów w rozdziale i underfull vboxami przez nie generowanymi? (pakiet float i zdefiniowanie otoczenia \begin{pseudocode}\vspace{-.5cm} ... \vspace{-.8cm}\end{pseudocode} (?)) -- na str. 215 i 216 w polskiej wersji Podręcznika jest podzielony pseudokod na dwie strony, ale w wersji angielskiej pseudokody nie są łamane
- a może podzielić kod źródłowy na katalogi, jeden na rozdział (albo jeden na część) i trzymać tam pliki źródłowe, jeden na podrozdział + plik rozdziału załączający je + kod z rysunkami?
- przejrzeć: http://clrs.skanev.com -- ch09, ch10, ch11, appc
- ostateczne zmiany w layoucie, konwencjach itd. -- takie, które dotyczą wszystkich wspólnych aspektów rozdziałów
- ostateczne strony początkowe i końcowe
- uporządkować cormensol.tex, cormensol.sty (poprawić polecenia wyświetlające liczniki)

ROADMAP DLA 0.6:
- part VI

ROADMAP DLA 0.7:
- part IV

ROADMAP DLA 0.8:
- part V

ROADMAP DLA 0.9:
- ch27, ch28, ch29, ch30

ROADMAP DLA 1.0-alpha:
- ch31, ch32, ch33, ch34, ch35
- poprawić/zweryfikować wszystkie odłożone rzeczy
- w razie potrzeby przepisać wstęp

ROADMAP DLA 1.0-beta:
(zadania zaznaczane jako rozwiązane poprawnie, ale w których można dokonać poprawek/ulepszeń po przerobieniu całości materiału)
1 -- sprawdzić cały rozdział po zrobieniu wszystkich pozostałych
6-3(c) -- uprościć pseudokod
8.3-2 -- jak obliczać złożoność pamięciową? w manualu jest analiza na bitach i wychodzi O(n\lg n) zamiast O(n)
9-2(e) -- opisać ThreeWayPartition i Select' (jeśli nigdzie indziej nie będą rozważane, a jeśli będą, to podlinkować tamto zadanie), zastanowić się nad złożonością Selecta, gdy elementy w tablicy wejściowej powtarzają się
10-2(b) -- które operacje działają w czasach zamortyzowanych, a które w "zwykłych"? (po ch20)
10-2 -- czy można zaimplementować kopiec złączalny szybciej? (po ch21)
B-3(a) -- uprościć dowód

ROADMAP DLA 1.0:
- ostateczne sprawdzenie w wersji wydrukowanej

ROADMAP PO 1.0:
- rozwiązania zadań i problemów z wydania 3 (na podstawie polskiej wersji)
- sprawdzić, czy rozwiązania zadań, które były w wydaniu 2, nadal zgadzają się z treściami tych zadań w wydaniu 3
- sprawdzić, czy wszystkie notki są aktualne
- clrscode3e zamiast clrscode
- przerobić na stronę WWW wykorzystującą MathJax
- przetłumaczyć na język angielski (traktując jako źródło oryginalną wersję Podręcznika)
- utworzyć AlgoLib (w Javie lub C++) - bibliotekę przydatnych algorytmów i struktur danych na podstawie CormenImpl i implementacji Sedgewicka
- przeprowadzić testy wydajnościowe dla algorytmów w AlgoLib i porównać czasy algorytmów z ich złożonościami

IMPLEMENTACJE
- Czy zrezygnować z algorytmów parametryzowanych typami, gdy w Podręczniku są one omawiane tylko jako algorytmy na liczbach całkowitych? (np. kopiec byłby tylko dla liczb całkowitych, a w razie potrzeby implementowałoby się specjalne procedury dla kopca zawierającego inne elementy)
- Dopisać ograniczenia parametrów w Javadocach? (multiaryParent).

DODATEK A
DODATEK B
DODATEK C

ROZDZIAŁ 1
ROZDZIAŁ 2
ROZDZIAŁ 3
ROZDZIAŁ 4
4-2 -- Czy dokładanie nowych liczb nie kłóci się z zabronionym dostępem do całych liczb? A jeśli dokładamy, to opisać dokładnie jaki będzie rozmiar nowej tablicy (chyba nie 2^k-1) i opisać jakie liczby są dokładane.

ROZDZIAŁ 5
5.4-2 -- porównać z http://en.wikipedia.org/wiki/Birthday_problem#Average_number_of_people, właściwie to Knuth nie rozważa tej sumy z końca wyprowadzenia, zastanowić się jak można osiągnąć postać Q(b) z Knutha

ROZDZIAŁ 6
ROZDZIAŁ 7
ROZDZIAŁ 8
8-2(e) -- przerobić opis, implementacja ok (czy algorytm jest stabilny?), czy w pseudokodzie możemy przypisywać bezpośrednio tablicę do innej tablicy? czy może być taki podwójny warunek w ifie?

ROZDZIAŁ 9
9.3(a) -- uaktualnić opis nowej wersji algorytmu, czy zrobić osobny paragraf wyjaśniający szczegóły implementacyjne?

ROZDZIAŁ 10
10.3-1 -- czy pole free jest zbędne?
10.3-2 -- skoro w procedurach Allocate-Object i Free-Object nie przekazuje się tablic next, key, prev i wskaźników free, L, to przekazywanie tablicy A tutaj jest zbędne (?), czy Single-Array- to dobry prefiks dla tych procedur? W procedurach można by używać x zamiast i, analogicznie jak to jest w procedurach dla reprezentacji wielotablicowej.
10.3-4 -- Wspomnieć nazwę Compact-List-Allocate-Object albo zmienić pozycję na liście implementacji. Przypomnieć, że n oznacza liczbę elementów na liście w reprezentacji wielotablicowej.
10.3-5 -- użycie n+1 jako niepoprawnej wartości dla pól prev jest nieuzasadnione, zamiast n+1 użyć nieskończoności. Można wspomnieć o tym, że po zakończeniu działania algorytmu lista free nie stanowi stosu, na czym polegają procedury Allocate-Object i Free-Object z 10.3-4.
10.4-5 -- opisać
10-2 -- sprawdzić na http://clrs.skanev.com
10-2(a) -- dlaczego staramy się, aby elementy nie powtarzały się? w operacji Union nie korzystamy z procedury Merge tylko z algorytmu opisanego w 6.5-8
10-3(e) -- czy zamiast pierwszej nierówności nie powinna być równość? sprawdzić, czy w (c) rzeczywiście zachodzi równość, jeśli nie, to poprawić, jeśli tak, to można wspomnieć że pokazana została równość zamiast nierówności. A w (e) korzystamy z twierdzenia (słabszego wyniku), a nie z dowodu (mocniejszego).

ROZDZIAŁ 11
11.1-1 -- co zwróci procedura, gdy tablica będzie pusta?
11.1-3 -- usuwanie chyba nie będzie takie proste - procedura przyjmuje wskaźnik do elementu, a nie do node'a listy z tym elementem
11.1-4 -- tablice nie mogą się rozszerzać i kurczyć, stos na tablicy może. Jaki przyjąć rozmiar początkowy tablicy? Napisać parę słów o przepełnieniu. Zamiast opisów i ciągów instrukcji wstawić pełne pseudokody (używające Push i Pop). Czy notka ok? Można zrezygnować z tablicy S' -- patrz implementacja.
11.2-4 -- co oznacza pojęcie "pojedyncza lista dwukierunkowa"? zaimplementowano tak, że listy elementów też są dwukierunkowe (tablica nie jest heterogenicznym typem), wspomnieć w operacji usuwania, że przestawiamy flagę free elementu na true, a poza tym, czy potrzebna jest flaga free? Może o zajętości pola decydowałoby pole elementu (NIL lub nie-NIL)? Można nawiązać, że tablica przypomina listę w reprezentacji jednotablicowej.

ROZDZIAŁ 12
12.2-5 -- dokończyć
>> Niech x będzie węzłem drzewa, y jego następnikiem, a z -- lewym synem y. Zachodzi z<x<y. Można nawiązać do inordera, że wtedy x musiałoby być na ścieżce między x a y. Albo pokazać, że y i z nie mogą być ani w prawym, ani w lewym poddrzewie x. Pozostaje udowodnić, że nie mogą być też "nad" x.
12.2-6 >> Gdzie szukać następnika x? Nie ma prawego poddrzewa, a w lewym są same mniejsze niż x. Poruszajmy się więc w górę drzewa od x. Jeśli na ścieżce do korzenia nie ma takiego przodka x, z którego lewy syn byłby przodkiem x, to x jest największy w drzewie i nie ma następnika. A więc z może być następnikiem i trzeba pokazać, że żadne prawe poddrzewo na ścieżce od z do korzenia nie zawiera elementów większych niż z. Tylko co z lewymi poddrzewami?
12.2-7
12.2-8 >> Udowodnić, że w ten sposób zostaje odwiedzonych kilka poddrzew drzewa z wyjątkiem być może pierwszego i ostatniego węzła. Na mocy 12.2-7 wynika, że czas odwiedzenia tych poddrzew wynosi \Theta(k), a suma długości ścieżki między pierwszym węzłem a pierwszym poddrzewem i ścieżki między ostatnim poddrzewem a ostatnim węzłem wynosi O(h).
12.2-9 -- nie można w ten sposób skorzystać z 12.2-6, bo tamto zadanie zakłada, że poddrzewo danego węzła jest puste
12.3-1 --
12.3-2
12.3-3 --
12.3-4 >> procedura wywołująca Tree-Delete może umieścić następnik węzła z na liście wolnych pozycji
12.3-5 >> operacja nie jest przemienna, kontrprzykład: drzewo 4(3,7(6)), usuwamy węzły 4, 3
12.3-6 >> w linii 3 w Tree-Delete byłoby '\If \proc{Random}(0,1)=0 \Then y\gets\proc{Tree-Successor(z)} \Else y\gets\proc{Tree-Predecessor(z)}'
12.4-2
12.4-3
12.4-4
12.4-5
12-1(a)
12-1(b)
12-1(c)
12-1(d)
12-3(a)
12-3(b)
12-3(c)
12-3(d)
12-3(e)
12-3(f)
12-4 -- błędnie podana definicja rozwinięcia Taylora, poprawna w oryginale
12-4(a)
12-4(b)
12-4(c)
12-4(d)

ROZDZIAŁ 13
13.1-1
13.1-2
13.1-3
13.1-4
13.1-5
13.1-6
13.1-7
13.2-1
13.2-2
13.2-3
13.2-4
13.2-5
13.3-1
13.3-2
13.3-3
13.3-4
13.3-5
13.3-6
13.4-1
13.4-2
13.4-3
13.4-4
13.4-5
13.4-6
13.4-7
13-1(a)
13-1(b)
13-1(c)
13-1(d)
13-1(e)
13-2(a)
13-2(b)
13-2(c)
13-2(d)
13-2(e)
13-2(f)
13-3(a)
13-3(b)
13-3(c)
13-3(d)
13-4(a)
13-4(b)
13-4(c)
13-4(d)
13-4(e)
13-4(f)
13-4(g)
13-4(h)
13-4(i)
13-4(j)

ROZDZIAŁ 14
14.1-1
14.1-2
14.1-3
14.1-4
14.1-5
14.1-6
14.1-7
14.1-8
14.2-1
14.2-2
14.2-3
14.2-4
14.2-5
14.3-1
14.3-2
14.3-3
14.3-4
14.3-5
14.3-6
14.3-7
14-1(a)
14-1(b)
14-2(a)
14-2(b)