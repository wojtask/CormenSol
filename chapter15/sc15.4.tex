\subchapter{Najdłuższy wspólny podciąg}

\exercise %15.4-1
Dla zadanych ciągów NWP wyznaczonym przez procedury \proc{LCS-Length} i~\proc{Print-LCS} jest $\langle1,0,0,1,1,0\rangle$.
Poza nim istnieje jeszcze 7 innych NWP tych ciągów:
\begin{gather*}
	\langle0,0,1,0,1,0\rangle, \langle0,0,1,0,1,1\rangle, \langle0,0,1,1,0,1\rangle, \langle0,1,0,1,0,1\rangle, \\
	\langle1,0,1,0,1,0\rangle, \langle1,0,1,0,1,1\rangle, \langle1,0,1,1,0,1\rangle.
\end{gather*}

\exercise %15.4-2
Poniższy pseudokod stanowi implementację zmodyfikowanej wersji procedury \proc{Print-LCS}, która wypisuje NWP ciągów $X$, $Y$ bez korzystania z~tablicy $b$.
\begin{codebox}
\Procname{$\proc{Print-LCS}'(c,X,Y,i,j)$}
\li	\If $i=0$ lub $j=0$
\li		\Then \Return
		\End
\li	\If $x_i=y_j$
\li		\Then $\proc{Print-LCS}'(c,X,Y,i-1,j-1)$
\li			wypisz $x_i$
\li		\ElseIf $c[i,j]=c[i-1,j]$
\li			\Then $\proc{Print-LCS}'(c,X,Y,i-1,j)$
\li		\ElseNoIf $\proc{Print-LCS}'(c,X,Y,i,j-1)$
		\End
\end{codebox}

\exercise %15.4-3
W~naszej implementacji będziemy obliczać kolejne wartości rekurencyjnie bezpośrednio ze wzoru (15.14), ale z~wykorzystaniem tablicy $c[1\twodots m,1\twodots n]$ i~mechanizmu spamiętywania.
Aby zaznaczyć, że dane pole tablicy $c$ nie zostało jeszcze obliczone, użyjemy specjalnej wartości $\infty$.
Pierwsza z~procedur inicjalizuje tablicę $c$, po czym wywołuje właściwy algorytm odpowiedzialny za obliczenie wartości $c[m,n]$.
\begin{codebox}
\Procname{$\proc{Memoized-LCS-Length}(X,Y)$}
\li	$m\gets\attrib{X}{length}$
\li	$n\gets\attrib{Y}{length}$
\li	\For $i\gets0$ \To $m$
\li		\Do \For $j\gets0$ \To $n$
\li				\Do $c[i,j]\gets\infty$ \label{li:memoized-lcs-length-init}
				\End
		\End
\li	\Return $\proc{Lookup-LCS}(c,X,Y,m,n)$
\end{codebox}
\begin{codebox}
\Procname{$\proc{Lookup-LCS}(c,X,Y,i,j)$}
\li	\If $c[i,j]<\infty$
\li		\Then \Return $c[i,j]$
		\End
\li	\If $i=0$ lub $j=0$
\li		\Then $c[i,j]\gets0$
\li		\ElseIf $x_i=y_j$
\li			\Then $c[i,j]\gets\proc{Lookup-LCS}(c,X,Y,i-1,j-1)+1$
\li		\ElseNoIf $c[i,j]\gets\max(\proc{Lookup-LCS}(c,X,Y,i,j-1),\proc{Lookup-LCS}(c,X,Y,i-1,j))$
		\End
\li	\Return $c[i,j]$
\end{codebox}

Każde z~$(m+1)(n+1)$ pól tablicy $c$ zostaje zainicjalizowane w~wierszu \ref{li:memoized-lcs-length-init}, a~następnie zmodyfikowane przez jedno wywołanie procedury \proc{Lookup-LCS}.
Wywołania procedury \proc{Lookup-LCS} możemy podzielić na dwa typy:
\begin{enumerate}
	\item wywołania, w~których $c[i,j]=\infty$, oraz
	\item wywołania, w~których $c[i,j]<\infty$.
\end{enumerate}
Wywołań pierwszego typu jest dokładnie $\Theta(mn)$, jedno na każde pole tablicy $c$.
Wszystkie wywołania drugiego typu pojawiają się jako rekurencyjne wywołania w~wywołaniach pierwszego typu.
Kiedy w~danym wywołaniu \proc{Lookup-LCS} pojawiają się wywołania rekurencyjne, jest ich $\Theta(1)$, dlatego łącznie wywołań drugiego typu jest $\Theta(mn)$.
Każde wywołanie drugiego typu zabiera czas $\Theta(1)$, a~każde wywołanie pierwszego typu jest wykonywane w~czasie $O(1)$ plus czas spędzany na obliczenia rekurencyjne.
Dlatego łączny czas wykonania algorytmu \proc{Memoized-LCS-Length} wynosi $\Theta(mn)$.

\exercise %15.4-4
Zauważmy, że do obliczenia $c[i,j]$ w~procedurze \proc{LCS-Length} wykorzystywane są wartości $c[i-1,j]$, $c[i,j-1]$ lub $c[i-1,j-1]$.
Możemy więc utrzymywać tylko 2 wiersze tablicy $c$ -- wiersz aktualnie obliczany oraz wiersz bezpośrednio go poprzedzający.
Po każdej iteracji poprzedni wiersz będzie nadpisywany wartościami z~bieżącego wiersza, aby przygotować tablicę do kolejnej iteracji.
Aby tablica $c$ była rozmiaru $2\cdot\min(m,n)$, przed jej utworzeniem należy jeszcze sprawdzić, czy $n\le m$.
Jeśli nie, to wystarczy uruchomić procedurę z~ciągami $X$ i~$Y$ zamienionymi miejscami.

Można jednak jeszcze bardziej ograniczyć zapotrzebowanie procedury na pamięć.
Dwuwymiarowa tablica $c$ może zostać zamieniona na jednowymiarową tablicę $C[1\twodots n]$, która reprezentować będzie aktualnie obliczany wiersz tablicy $c$ w~trakcie działania procedury.
W~momencie obliczania $c[i,j]$ reprezentowanego przez $C[j]$, komórka $C[j]$ przechowuje wartość $c[i-1,j]$ z~poprzedniego wiersza.
Jeśli w~osobnej zmiennej $p$ zapamiętamy $c[i-1,j-1]$, czyli wartość $C[j-1]$ przed jej aktualizacją, to będziemy dysponować wszystkimi danymi potrzebnymi do obliczenia $C[j]$.
Jeśli $x_i=y_j$, to $C[j]$ ustawione zostanie na $p+1$, co odpowiada wierszowi 10 z~oryginalnej procedury \proc{LCS-Length}.
W~przeciwnym przypadku do $C[j]$ wpisane zostanie $\max(C[j],C[j-1])$, co odpowiada wierszom \doubledash{12}{16}.
Ostatnim krokiem w~bieżącej iteracji pętli jest aktualizacja zmiennej $p$ na wartość znajdującą się w~$C[j]$ przed modyfikacją tej komórki.
Dzięki tak wprowadzonym zmianom w~procedurze wykorzystujemy $\min(m,n)+\Theta(1)$ pamięci.

\exercise %15.4-5
W~problemie najdłuższego niemalejącego podciągu (w~skrócie: NNP) dla danego ciągu $X=\langle x_1,x_2,\dots,x_n\rangle$ szukany jest podciąg ciągu $X$ o~największej możliwej długości, którego wyrazy ustawione są w~porządku niemalejącym.
Przez $c[i]$ oznaczmy długość najdłuższego niemalejącego podciągu ciągu $X$, w~którym ostatnim wyrazem jest $x_i$.
NNP ciągu $X$ zakończony wyrazem $x_i$ składa się z~NNP prefiksu $X_{i-1}$ z~dołączonym na końcu $x_i$, o~ile tylko NNP prefiksu $X_{i-1}$ zakończony jest wyrazem $x_j\le x_i$.
Jeśli nie istnieje takie $1\le j<i$, to NNP ciągu $X$ jest $\langle x_i\rangle$.
Problem ma zatem własność optymalnej podstruktury.
Aby znaleźć długość NNP danego ciągu, należy wpierw znaleźć rozwiązania podproblemów, czyli długości NNP prefiksów tego ciągu.
Otrzymujemy zależność rekurencyjną:
\[
	c[i] = \begin{cases}
		1, & \text{jeśli $x_j>x_i$ dla każdego $1\le j<i$}, \\
		\displaystyle\max_{\substack{1\le j<i\\x_j\le x_i}}(c[j])+1, & \text{w~przeciwnym przypadku}.
	\end{cases}
\]
NNP ciągu $X$ ma wówczas długość $\max_{1\le i\le n}c[i]$.

Obliczanie $c[n]$ bezpośrednio z~definicji doprowadziłoby do algorytmu o~czasie wykładniczym z~racji wielokrotnego rozwiązywania tych samych podproblemów.
Dzięki wykorzystaniu tablicowania wyników w~programowaniu dynamicznym, możemy podać algorytm działający w~czasie $O(n^2)$.
\begin{codebox}
\Procname{$\proc{LIS-Length}(X)$}
\li	$n\gets\attrib{X}{length}$
\li	$\id{longest}\gets0$
\li	$b^*\!\gets0$
\li	\For $i\gets1$ \To $n$ \label{li:lis-length-computing-c-begin}
\li		\Do $c[i]\gets1$
\li			$b[i]\gets0$
\li			\For $j\gets1$ \To $i-1$
\li				\Do \If $x_j\le x_i$ i~$c[j]+1>c[i]$
\li						\Then $c[i]\gets c[j]+1$
\li							$b[i]\gets j$
						\End
				\End
\li			\If $c[i]>\id{longest}$
\li				\Then $\id{longest}\gets c[i]$
\li					$b^*\!\gets i$
				\End
		\End \label{li:lis-length-computing-c-end}
\li	\Return $\id{longest}$, $b$ i~$b^*$
\end{codebox}
W~pętli \kw{for} w~wierszach \doubledash{\ref{li:lis-length-computing-c-begin}}{\ref{li:lis-length-computing-c-end}} wyznaczane są kolejne pola tablicy $c$, a~także aktualizowana jest zmienna \id{longest} przechowująca maksimum aktualnie znanego NNP wejściowego ciągu $X$.
W~tablicy $b[1\twodots n]$ zapamiętywane są dodatkowe informacje służące później do odtworzenia znalezionego NNP.
Dokładniej, po zakończeniu działania procedury, w~$b[i]$ znajduje się ta wartość $j$, dla której $c[i]=c[j]+1$, albo $b[i]=0$, jeżeli takie $j$ nie istnieje.
Ponadto, $b^*\!$ przechowuje takie $i$, dla którego $\id{longest}=c[i]$, albo 0, jeżeli ciąg $X$ jest pusty.

Znaleziony podciąg można otrzymać (w~odwrotnej kolejności) poprzez wypisanie $x_{b^*\!}$, a~następnie $x_{b[b^*\!]}$, $x_{b[b[b^*\!]]}$ itd., dopóki indeks nie jest zerem.
Następująca rekurencyjna procedura pozwala wypisać NNP we właściwej kolejności.
\begin{codebox}
\Procname{$\proc{Print-LIS}(b,X,i)$}
\li	\If $i>0$
\li		\Then $\proc{Print-LIS}(b,X,b[i])$
\li			wypisz $x_i$
		\End
\end{codebox}
Dysponując tablicą $b$ i~wartością $b^*\!$ wyznaczonymi dla danego ciągu $X$, możemy wypisać NNP ciągu $X$, wywołując $\proc{Print-LIS}(b,X,b^*\!)$.

\exercise %15.4-6

