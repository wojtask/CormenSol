\subchapter{Optymalne drzewa wyszukiwań binarnych}

\exercise %15.5-1
Algorytm podzielimy na 3 procedury.
Pierwsza z~nich ma za zadanie wypisać korzeń optymalnego drzewa BST oraz wywołać drugą, rekurencyjną procedurę wypisującą strukturę tego drzewa.
W~tej ostatniej, dla danej tablicy \id{root} oraz pozycji $i\le j$, konstruowane jest poddrzewo o~korzeniu, którego indeks znajduje się w~$\id{root}[i,j]$.
Konstrukcja ta polega na wypisaniu jego lewego poddrzewa, a~następnie na wypisaniu jego prawego poddrzewa.
Trzecia procedura służy nam do pozyskiwania nazw węzłów na podstawie wartości w~tablicy \id{root} oraz pozycji w~niej.
\begin{codebox}
\Procname{$\proc{Construct-Optimal-BST}(\id{root})$}
\li	$n\gets\attribii{root}{length}$
\li	wypisz $\proc{Optimal-BST-Node}(\id{root},i,n)$ ,, jest korzeniem''
\li	$\proc{Construct-Optimal-BST-Subtree}(\id{root},1,n)$
\end{codebox}
\begin{codebox}
\Procname{$\proc{Construct-Optimal-BST-Subtree}(\id{root},i,j)$}
\li	\If $i\le j$
\li		\Then wypisz $\proc{Optimal-BST-Node}(\id{root},i,\id{root}[i,j]-1)$ ,, jest lewym synem $k$''$\!{}_{\id{root}[i,j]}$
\li			$\proc{Construct-Optimal-BST-Subtree}(\id{root},i,\id{root}[i,j]-1)$
\li			wypisz $\proc{Optimal-BST-Node}(\id{root},\id{root}[i,j]+1,j)$ ,, jest prawym synem $k$''$\!{}_{\id{root}[i,j]}$
\li			$\proc{Construct-Optimal-BST-Subtree}(\id{root},\id{root}[i,j]+1,j)$
		\End
\end{codebox}
\begin{codebox}
\Procname{$\proc{Optimal-BST-Node}(\id{root},i,j)$}
\li	\If $i\le j$
\li		\Then \Return ,,$k$''$\!{}_{\id{root}[i,j]}$
\li		\Else \Return ,,$d$''$\!{}_j$
\end{codebox}

\exercise %15.5-2
Algorytm \proc{Optimal-BST} wywołany dla zadanych prawdopodobieństw zwraca optymalne drzewo BST przedstawione na rys.\ \ref{fig:15.5-2}.
\begin{figure}[!ht]
	\centering \input{fig15.5-2}
	\caption{Optymalne drzewo BST dla podanych danych wejściowych.} \label{fig:15.5-2}
\end{figure}
Podobnie jak w~Podręczniku, w~poniższej tabeli przedstawiony został wkład każdego węzła w~tym drzewie i~wyznaczony koszt tego drzewa.
\begin{table}[!ht]
	\centering
		\begin{tabular}{cccc}
			węzeł & głębokość & prawdopodobieństwo & wkład \\ \hline
			$k_1$ & 2 & 0{,}04 & 0{,}12 \\
			$k_2$ & 1 & 0{,}06 & 0{,}12 \\
			$k_3$ & 2 & 0{,}08 & 0{,}24 \\
			$k_4$ & 3 & 0{,}02 & 0{,}08 \\
			$k_5$ & 0 & 0{,}10 & 0{,}10 \\
			$k_6$ & 2 & 0{,}12 & 0{,}36 \\
			$k_7$ & 1 & 0{,}14 & 0{,}28 \\
			$d_0$ & 3 & 0{,}06 & 0{,}24 \\
			$d_1$ & 3 & 0{,}06 & 0{,}24 \\
			$d_2$ & 3 & 0{,}06 & 0{,}24 \\
			$d_3$ & 4 & 0{,}06 & 0{,}30 \\
			$d_4$ & 4 & 0{,}05 & 0{,}25 \\
			$d_5$ & 3 & 0{,}05 & 0{,}20 \\
			$d_6$ & 3 & 0{,}05 & 0{,}20 \\
			$d_7$ & 2 & 0{,}05 & 0{,}15 \\ \hline
			Razem & & & 3{,}12
		\end{tabular}
\end{table}

\exercise %15.5-3
Obliczanie wartości $w(i,j)$ bezpośrednio ze wzoru (15.17) wymaga wykonania $\Theta(j-i)$ dodawań.
Zauważmy, że pętla \kw{for} w~wierszach \doubledash{9}{13} wykonuje także $\Theta(j-i)$ iteracji, każda wymagająca czasu stałego.
A~zatem modyfikacja ta nie wpłynie na asymptotyczny czas działania algorytmu, tylko co najwyżej na zwiększenie stałego czynnika ukrytego w~notacji $\Theta$.

\exercise %15.5-4
Wykorzystamy podany fakt i~w~najbardziej wewnętrznej pętli procedury \proc{Optimal-BST}, zamiast iterować zmienną $r$ od $i$ do $j$, będziemy przebiegać wszystkie wartości od $\id{root}[i,j-1]$ do $\id{root}[i+1,j]$.
Pokażemy, że tablice $e$ i~\id{root} zostaną wypełnione w~czasie $\Theta(n^2)$.
Dla pewnego ustalonego $l$ pętla \kw{for} w~wierszach \doubledash{4}{13} wykona $\sum_{i=1}^{n-l+1}(\id{root}[i+1,j]-\id{root}[i,j-1]+1)$ iteracji.
Po podstawieniu $j=i+l-1$ otrzymujemy
\begin{align*}
	\sum_{i=1}^{n-l+1}(\id{root}[i+1,j]-\id{root}[i,j-1]+1) &= \sum_{i=1}^{n-l+1}(\id{root}[i+1,i+l-1]-\id{root}[i,i+l-2]+1) \\
	&= \sum_{i=1}^{n-l+1}(\id{root}[i+1,i+l-1]-\id{root}[i,i+l-2])+\sum_{i=1}^{n-l+1}1 \\
	&= \id{root}[n-l+2,n]-\id{root}[1,l-1]+n-l+1.
\end{align*}
W~ostatniej równości skorzystaliśmy z~własności sumy teleskopowej.
Największą możliwą wartością różnicy $\id{root}[n-l+2,n]-\id{root}[1,l-1]$ jest $n-1$, więc liczbę iteracji pętli można ograniczyć z~góry przez $n-1+n-l+1\le2n$.

Zmienna $l$ przyjmuje $n$ wartości, a~więc sumaryczna liczba iteracji w~procedurze wynosi co najwyżej $O(n^2)$.
Dolne ograniczenie $\Omega(n^2)$ zachodzi oczywiście, bo obliczana jest każda z~$n(n+1)/2$ z~komórek tablic $e$ i~\id{root}.
Stąd czasem działania algorytmu jest $\Theta(n^2)$.
