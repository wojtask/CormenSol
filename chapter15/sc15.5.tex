\subchapter{Optymalne drzewa wyszukiwań binarnych}

\exercise %15.5-1
Algorytm podzielimy na 3 procedury.
Pierwsza z~nich ma za zadanie wypisać korzeń optymalnego drzewa BST oraz wywołać drugą, rekurencyjną procedurę wypisującą strukturę tego drzewa.
W~tej ostatniej, dla danej tablicy \id{root} oraz pozycji $i\le j$, konstruowane jest poddrzewo o~korzeniu, którego indeks znajduje się w~$\id{root}[i,j]$.
Konstrukcja ta polega na wypisaniu jego lewego poddrzewa, a~następnie na wypisaniu jego prawego poddrzewa.
Trzecia procedura służy nam do pozyskiwania nazw węzłów na podstawie wartości w~tablicy \id{root} oraz pozycji w~niej.
\begin{codebox}
\Procname{$\proc{Construct-Optimal-BST}(\id{root})$}
\li	$n\gets\attribii{root}{length}$
\li	wypisz $\proc{Optimal-BST-Node}(\id{root},i,n)$ ,, jest korzeniem''
\li	$\proc{Construct-Optimal-BST-Subtree}(\id{root},1,n)$
\end{codebox}
\begin{codebox}
\Procname{$\proc{Construct-Optimal-BST-Subtree}(\id{root},i,j)$}
\li	\If $i\le j$
\li		\Then wypisz $\proc{Optimal-BST-Node}(\id{root},i,\id{root}[i,j]-1)$ ,, jest lewym synem $k$''$\!{}_{\id{root}[i,j]}$
\li			$\proc{Construct-Optimal-BST-Subtree}(\id{root},i,\id{root}[i,j]-1)$
\li			wypisz $\proc{Optimal-BST-Node}(\id{root},\id{root}[i,j]+1,j)$ ,, jest prawym synem $k$''$\!{}_{\id{root}[i,j]}$
\li			$\proc{Construct-Optimal-BST-Subtree}(\id{root},\id{root}[i,j]+1,j)$
		\End
\end{codebox}
\begin{codebox}
\Procname{$\proc{Optimal-BST-Node}(\id{root},i,j)$}
\li	\If $i\le j$
\li		\Then \Return ,,$k$''$\!{}_{\id{root}[i,j]}$
\li		\Else \Return ,,$d$''$\!{}_j$
\end{codebox}

\exercise %15.5-2
Algorytm \proc{Optimal-BST} wywołany dla zadanych prawdopodobieństw zwraca optymalne drzewo BST przedstawione na rys.\ \ref{fig:15.5-2}.
\begin{figure}[!ht]
	\centering \input{fig15.5-2}
	\caption{Optymalne drzewo BST dla podanych danych wejściowych.} \label{fig:15.5-2}
\end{figure}
Podobnie jak w~Podręczniku, w~poniższej tabeli przedstawiony został wkład każdego węzła w~tym drzewie i~wyznaczony koszt tego drzewa.
\begin{table}[!ht]
	\centering
		\begin{tabular}{cccc}
			węzeł & głębokość & prawdopodobieństwo & wkład \\ \hline
			$k_1$ & 2 & 0{,}04 & 0{,}12 \\
			$k_2$ & 1 & 0{,}06 & 0{,}12 \\
			$k_3$ & 2 & 0{,}08 & 0{,}24 \\
			$k_4$ & 3 & 0{,}02 & 0{,}08 \\
			$k_5$ & 0 & 0{,}10 & 0{,}10 \\
			$k_6$ & 2 & 0{,}12 & 0{,}36 \\
			$k_7$ & 1 & 0{,}14 & 0{,}28 \\
			$d_0$ & 3 & 0{,}06 & 0{,}24 \\
			$d_1$ & 3 & 0{,}06 & 0{,}24 \\
			$d_2$ & 3 & 0{,}06 & 0{,}24 \\
			$d_3$ & 4 & 0{,}06 & 0{,}30 \\
			$d_4$ & 4 & 0{,}05 & 0{,}25 \\
			$d_5$ & 3 & 0{,}05 & 0{,}20 \\
			$d_6$ & 3 & 0{,}05 & 0{,}20 \\
			$d_7$ & 2 & 0{,}05 & 0{,}15 \\ \hline
			Razem & & & 3{,}12
		\end{tabular}
\end{table}

\exercise %15.5-3
Obliczanie wartości $w(i,j)$ bezpośrednio ze wzoru (15.17) wymaga wykonania $\Theta(j-i)$ dodawań.
Zauważmy, że pętla \kw{for} w~wierszach \doubledash{9}{13} wykonuje także $\Theta(j-i)$ iteracji, każda wymagająca czasu stałego.
A~zatem modyfikacja ta nie wpłynie na asymptotyczny czas działania algorytmu, tylko co najwyżej na zwiększenie stałego czynnika ukrytego w~notacji $\Theta$.

\exercise %15.5-4
