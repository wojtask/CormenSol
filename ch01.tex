\section*{Rozdział 1: Rola algorytmów w obliczeniach}

\subsection*{1.1. Algorytmy}

\paragraph{1.1-1.}
\begin{description}
	\item[sortowanie:] porządkowanie po rozdaniu kart w ręku względem ich wartości,
	\item[optymalna kolejność mnożenia macierzy:] wyznaczanie transformacji graficznych (np. skalowań, obrotów); przekształcenia te opisane są za pomocą macierzy, a ich składanie oznacza obliczenie iloczynu tych macierzy,
	\item[otoczka wypukła:] mając zbiór wbitych w ziemię palików, chcemy otoczyć je wszystkie siatką ogrodzeniową opierając ją na niektórych palikach tak, by zużyć jej jak najmniej.
\end{description}

\paragraph{1.1-2.}
\begin{itemize}
  \item minimalizacja zużycia pamięci (operacyjnej i masowej)
  \item minimalizacja wykorzystania systemu operacyjnego
  \item minimalizacja dostępu do bazy danych
  \item minimalizacja eksploatacji łącza sieciowego
  \item dostosowanie do konkretnej architektury sprzętowo-programowej
  \item efektywność działania w architekturze równoległej lub rozproszonej
\end{itemize}

\paragraph{1.1-3.}
W następującej tabeli porównano listę dwukierunkową z prostszymi strukturami.\\
\begin{tabular}{l|l}
Zalety & Wady \\
\hline
%\begin{itemize}
%  nie trzeba z góry znać maksymalnego rozmiaru jak w przypadku tablicy, & \\
%  może się dowolnie rozszerzać i kurczyć, & \\
%  wstawianie i usuwanie elementów z dowolnego miejsca listy odbywa się w czasie stałym. & \\
%\end{itemize} &
%\begin{itemize}
%  zajmuje nieco więcej pamięci niż tablica (narzut na wskaźniki na poprzedni i następny element), & \\
%  nie można odnieść się do dowolnego elementu listy w stałym czasie, & \\
%  w przeciwieństwie do tablicy, lista nie zajmuje ciągłego obszaru pamięci, przez co kompilator nie ma możliwości dokonania pewnych optymalizacji przez przechowanie jej w pamięci podręcznej. & \\
%\end{itemize}
\end{tabular}

\paragraph{1.1-4.}
W tabeli zestawiono porównanie probelmu znajdowania najkrótszej ścieżki i problemu komiwojażera.
\begin{tabular}{l|l}
Podobieństwa & Różnice: \\
\hline
% \begin{itemize}
%   \item oba są problemami grafowymi,
%   \item oba mają na celu minimalizację pewnej ścieżki.
% \end{itemize} &
% \begin{itemize}
%   \item problem najkrótszej ścieżki poszukuje minimalnej ścieżki między dwoma wierzchołkami, a problem komiwojażera -- minimalny cykl uwzględniający wszystkie wierzchołki (minimalny cykl Hamiltona),
%   \item problem najkrótszej ścieżki jest wielomianowy (łatwo znaleźć efektywny algorytm dla tego problemu), podczas gdy problem komiwojażera jest \mbox{NP-zupełny} (prawdopodobnie nie istnieje dla niego efektywny algorytm).
% \end{itemize}
\end{tabular}

\paragraph{1.1-5.}
Problemem, którego pożądanym rozwiązaniem jest rozwiązanie dokładne, jest np. wyszukiwanie konkretnego elementu w nieuporządkowanej tablicy. Obecność jednego elementu w tablicy jest na ogół niezależna od obecności innego, zatem po sprawdzeniu kilku z nich, nie znajdując poszukiwanego elementu, nadal dysponujemy taką samą wiedzą jak przed rozpoczęciem sprawdzania.

Znalezienie rozwiązania przybliżonego jest natomiast wystarczające w wielu praktycznych zastosowaniach dla problemu komiwojażera.

\subsection*{1.2. Algorytmy jako technologia}

\paragraph{1.2-1.}
Przykładem aplikacji, w której wykorzystywanych jest wiele różnych algorytmów jest wspołczesna gra komputerowa. Jej silnik grafiki trójwymiarowej może być zaawansowanym środowiskiem, w którym zastosowano algorytmy geometrii obliczeniowej i renderowania grafiki 3D, jak również wiele algorytmów numerycznych do wyznaczania interpolacji oraz algorytmy grafowe. Także w dziedzinie sztucznej inteligencji opracowano wiele zaawansowanych algorytmów. Ponadto często spotykane problemy takie jak wyszukiwanie binarne czy sortowanie są rozwiązywane w niemal każdej aplikacji.

\paragraph{1.2-2.}
Nierówność $8n^2 < 64n\lg n$ jest spełniona dla $0<n\le 43$, zatem sortowanie przez wstawianie posortuje tablicę o rozmiarze nie przekraczającym $43$ szybciej niż sortowanie przez scalanie.

\paragraph{1.2-3.}
Najmniejszym dodatnim $n$ spełniającym nierówność $100n^2 < 2^n$ jest $n=14$.

\subsection*{Problemy}
%%zwezic jakos te tabelke
\paragraph{1-1. Porównanie czasów działania}
\begin{table}[h]
\[
  \begin{array}{c|c|c|c|c|c|c|c}
    &1&1&1&1&1&1&1 \\
	f(n) & \mbox{sekunda} & \mbox{minuta} & \mbox{godzina} & \mbox{dzień} & \mbox{miesiąc} & \mbox{rok} & \mbox{wiek} \\
	\hline
	\lg n & 2^{10^6} & 2^{6\cdot 10^7} & 2^{3.6\cdot 10^9} & 2^{8.64\cdot 10^{10}} & 2^{2.59\cdot 10^{12}} & 2^{3.15\cdot 10^{13}} & 2^{3.15\cdot 10^{14}} \\
	\hline
	\sqrt{n} & 10^{12} & 3.6\cdot 10^{15} & 1.3\cdot 10^{19} & 7.47\cdot 10^{21} & 6.72\cdot 10^{24} & 9.95\cdot 10^{26} & 9.95\cdot 10^{30} \\
	\hline
	n & 10^6 & 6\cdot 10^7 & 3.6\cdot 10^9 & 8.64\cdot 10^{10} & 2.59\cdot 10^{12} & 3.15\cdot 10^{13} & 3.15\cdot 10^{14} \\
	\hline
	n\lg n & 62746 & 2.8\cdot 10^6 & 1.3\cdot 10^8 & 2.75\cdot 10^9 & 7.18\cdot 10^{10} & 7.97\cdot 10^{11} & 6.86\cdot 10^{13} \\
	\hline
	n^2 & 1000 & 7745 & 60000 & 293938 & 1.61\cdot 10^6 & 5.62\cdot 10^6 & 5.62\cdot 10^7 \\
	\hline
	n^3 & 100 & 391 & 1532 & 4420 & 13736 & 31736 & 146645 \\
	\hline
	2^n & 19 & 25 & 31 & 36 & 41 & 44 & 51 \\
	\hline
	n! & 9 & 11 & 12 & 13 & 15 & 16 & 17
  \end{array}
\]
\caption{Czasy działania}
\end{table}
