\chapter{Drzewa wyszukiwań binarnych}

\subchapter{Co to jest drzewo wyszukiwań binarnych?}

\exercise %12.1-1
Przykładowe drzewa BST przedstawiono na rys.\ \ref{fig:12.1-1}.
\begin{figure}[ht]
	\begin{center}
		\includegraphics{fig_12.1-1}
	\end{center}
	\caption{Drzewa BST o~różnych wysokościach zawierające zbiór kluczy $\{1,4,5,10,16,17,21\}$.} \label{fig:12.1-1}
\end{figure}

\exercise %12.1-2
\note{Wyrażenie ,,właściwa kolejność'' użyte w~treści zadania oznacza kolejność niemalejącą.}

\noindent Niech $x$ będzie węzłem drzewa $T$, a~$y$, $z$, odpowiednio, lewym i~prawym synem $x$.
Jeśli drzewo $T$ byłoby drzewem BST, czyli spełniałoby własność drzewa BST, to wówczas prawdziwe byłyby nierówności $\attrib{y}{key}\le\attrib{x}{key}\le\attrib{z}{key}$.
Jeśli z~kolei drzewo $T$ stanowiłoby kopiec typu min, czyli spełniałoby własność kopca typu min, to zachodziłoby wtedy $\attrib{x}{key}\le\attrib{y}{key}$ oraz $\attrib{x}{key}\le\attrib{z}{key}$.

Ta różnica sprawia, że podczas przechodzenia kopca typu min w~kolejności niemalejących węzłów, po odwiedzeniu węzła $x$ nie jest wiadomo, które jego poddrzewo należałoby następnie odwiedzić, ponieważ nie jest znana relacja między $y$ a~$z$.
Oznacza to, że wypisanie wszystkich $n$ węzłów kopca typu min w~kolejności niemalejącej zajmuje czas wyższy niż $O(n)$.
W~przeciwnym przypadku moglibyśmy zaimplementować algorytm heapsort w~czasie liniowym.

\exercise %12.1-3
Nierekurencyjna wersja algorytmu przechodzenia drzewa metodą inorder, która wykorzystuje stos, została przedstawiona w~\refExercise{10.4-3}.
Nierekurencyjny algorytm o~identycznej funkcjonalności, ale niewykorzystujący stosu, został opisany w~\refExercise{10.4-5}.

\exercise %12.1-4
Algorytmy przechodzenia drzewa metodami preorder i~postorder przedstawiono poniżej.

\begin{codebox}
\Procname{$\proc{Preorder-Tree-Walk}(x)$}
\li	\If $x\ne\const{nil}$
\li		\Then
			wypisz \attrib{x}{key}
\li			$\proc{Preorder-Tree-Walk}(\attrib{x}{left})$
\li			$\proc{Preorder-Tree-Walk}(\attrib{x}{right})$
		\End
\end{codebox}

\begin{codebox}
\Procname{$\proc{Postorder-Tree-Walk}(x)$}
\li	\If $x\ne\const{nil}$
\li		\Then
			$\proc{Postorder-Tree-Walk}(\attrib{x}{left})$
\li			$\proc{Postorder-Tree-Walk}(\attrib{x}{right})$
\li			wypisz \attrib{x}{key}
		\End
\end{codebox}

Dla każdego z~tych algorytmów można udowodnić twierdzenie analogiczne do tw.\ 12.1, a~więc każdy z~nich działa w~czasie $\Theta(n)$ na drzewie \singledash{$n$}{wierzchołkowym}.

\exercise %12.1-5
Załóżmy nie-wprost, że istnieje algorytm konstruowania drzewa BST z~dowolnej listy $n$ elementów za pomocą porównań, którego pesymistyczny czas działania wynosi $o(n\lg n)$.
Na drzewie BST utworzonym za pomocą tego algorytmu moglibyśmy następnie uruchomić algorytm przechodzenia drzewa metodą inorder i~wypisać wszystkie jego klucze w~kolejności niemalejącej w~czasie $\Theta(n)$.
Posortowanie wejściowej listy $n$ elementów można byłoby wtedy przeprowadzić w~czasie niższym niż liniowo-logarytmiczny, co przeczyłoby tw.\ 8.1.

\subchapter{Wyszukiwanie w~drzewie wyszukiwań binarnych}

\exercise %12.2-1
Ciągi z~przykładów (a), (b) i~(d) są możliwe do uzyskania podczas wyszukiwania klucza 363 w~drzewie BST.
W~przykładzie (c) po odwiedzeniu węzła o~kluczu 911 przechodzimy do lewego poddrzewa, w~którym znajdują się węzły o~kluczach nie większych niż 911.
Jednakże później napotykamy 912, a~to nie jest możliwe w~drzewie BST.
W~przykładzie (e) występuje podobna sytuacja -- po odwiedzeniu węzła o~kluczu 347 przetwarzane jest prawe poddrzewo.
Klucz 299 napotykany później jest jednak mniejszy niż 347, co w~drzewie BST nie może mieć miejsca.

\exercise %12.2-2
Rekurencyjne wersje procedur zostały przedstawione poniżej.
\begin{codebox}
\Procname{$\proc{Recursive-Tree-Minimum}(x)$}
\li	\If $\attrib{x}{left}\ne\const{nil}$
\li		\Then \Return $\proc{Recursive-Tree-Minimum}(\attrib{x}{left})$
\li		\Else \Return $x$
		\End
\end{codebox}
\begin{codebox}
\Procname{$\proc{Recursive-Tree-Maximum}(x)$}
\li	\If $\attrib{x}{right}\ne\const{nil}$
\li		\Then \Return $\proc{Recursive-Tree-Maximum}(\attrib{x}{right})$
\li		\Else \Return $x$
		\End
\end{codebox}

\exercise %12.2-3
Procedura \proc{Tree-Predecessor} jest symetryczna do \proc{Tree-Successor}.
Jej pseudokod znajduje się poniżej.
\begin{codebox}
\Procname{$\proc{Tree-Predecessor}(x)$}
\li	\If $\attrib{x}{left}\ne\const{nil}$
\li		\Then \Return $\proc{Tree-Maximum}(\attrib{x}{left})$
		\End
\li	$y\gets\attrib{x}{p}$
\li	\While $y\ne\const{nil}$ i~$x=\attrib{y}{left}$
\li		\Do
			$x\gets y$
\li			$y\gets\attrib{y}{p}$
		\End
\li	\Return $y$
\end{codebox}

\exercise %12.2-4
Rys.\ \ref{fig:12.2-4} przedstawia najmniejsze drzewo BST, które obala postawioną hipotezę.
\begin{figure}[ht]
	\begin{center}
		\includegraphics{fig_12.2-4}
	\end{center}
	\caption{Najmniejszy kontrprzykład dla rozumowania profesora Bunyana.
W~drzewie tym szukano klucza $k=4$.
Jasnym kolorem zaznaczono jedyny węzeł o~kluczu należącym do zbioru $A$, a~ciemnym kolorem -- węzły o~kluczach ze zbioru $B$.
Zbiór $C$ w~tym przykładzie jest pusty.
Klucze 1 i~2 nie spełniają nierówności postawionej w~hipotezie.} \label{fig:12.2-4}
\end{figure}

\exercise %12.2-5
Niech $x$ będzie węzłem o~dwóch synach w~drzewie BST, a~$U$ zbiorem składającym się ze wszystkich przodków $x$, których lewe poddrzewa zawierają $x$.
Węzły o~kluczach większych niż \attrib{x}{key} znajdują się w~prawym poddrzewie $x$, a~także w~zbiorze $U$ i~w~prawych poddrzewach węzłów z~$U$.
Dla każdego $u\in U$, dla każdego węzła $v$ z~prawego poddrzewa $u$ i~dla każdego węzła $w$ z~prawego poddrzewa $x$ spełnione są nierówności $\attrib{x}{key}<\attrib{w}{key}<\attrib{u}{key}<\attrib{v}{key}$, a~to oznacza, że następnik $x$ znajduje się w~jego prawym poddrzewie.

Niech $y$ będzie następnikiem węzła $x$.
Jeśli węzeł $y$ miałby lewego syna $z$, to na podstawie faktu, że $y$ należy do prawego poddrzewa $x$, zachodziłoby $\attrib{x}{key}<\attrib{z}{key}<\attrib{y}{key}$, a~to z~kolei przeczyłoby faktowi, że następnikiem $x$ jest węzeł $y$.
Stąd następnik $x$ nie ma lewego syna.

Analogiczne rozumowanie przeprowadza się dla poprzednika węzła $x$.

\exercise %12.2-6
Niech $U$ będzie zbiorem zdefiniowanym jak w~\refExercise{12.2-5}.
Na podstawie rozumowania z~tamtego zadania mamy, że dla każdego $u\in U$ i~dla każdego węzła $v$ z~prawego poddrzewa $u$ zachodzą nierówności $\attrib{x}{key}<\attrib{u}{key}<\attrib{v}{key}$.
Następnik $y$ węzła $x$ jest więc elementem zbioru $U$ o~minimalnym kluczu.

Niech $u_1$, $u_2\in U$.
Węzeł $x$ należy do lewego poddrzewa zarówno $u_1$, jak i~$u_2$.
Węzły te nie mogą znajdować się w~drzewie $T$ na tej samej głębokości, bo wtedy ich lewe poddrzewa są rozłączne.
Załóżmy więc bez utraty ogólności, że $u_2$ leży w~$T$ głębiej niż $u_1$.
Wówczas węzeł $u_2$ oraz jego lewe poddrzewo znajdują się w~lewym poddrzewie węzła $u_1$.
Wynika stąd, że im głębszy poziom węzła ze zbioru $U$, tym mniejszy jego klucz, a~to oznacza, że następnikiem węzła $x$ jest najgłębszy węzeł z~$U$, czyli najniższy przodek $x$, którego lewy syn jest także przodkiem $x$.

\exercise %12.2-7
Wywołanie \proc{Tree-Minimum}, po którym następuje $n-1$ wywołań \proc{Tree-Successor}, spowoduje oczywiście wypisanie kluczy wszystkich $n$ węzłów drzewa w~tej samej kolejności, co wywołanie na tym drzewie \proc{Inorder-Tree-Walk}.
Jest w~sumie $n$ wywołań procedur -- algorytm wymaga więc czasu $\Omega(n)$.
Pokażemy jeszcze, że każda krawędź drzewa jest pokonywana co najwyżej dwukrotnie, skąd wynika górne oszacowanie $O(n)$ na czas działania algorytmu.

Niech $u$ będzie węzłem drzewa, a~$v$ jego lewym synem.
W~trakcie działania algorytmu przed wypisaniem klucza $u$ wpierw wypisane zostaną klucze wszystkich węzłów z~jego lewego poddrzewa, którego korzeniem jest $v$, co zostanie zapoczątkowane przez przejście krawędzią $\langle u,v\rangle$.
Następnie w~celu wypisania klucza $u$ procedura \proc{Tree-Successor} przejdzie w~górę drzewa ścieżką do $u$ od maksymalnego elementu poddrzewa o~korzeniu w~$v$.
Na tej ścieżce oczywiście znajduje się krawędź $\langle u,v\rangle$.
Po pokonaniu ścieżki krawędź ta nie zostanie ponownie wykorzystana, ponieważ wszystkie węzły w~lewym poddrzewie $u$ zostały już odwiedzone.

Załóżmy teraz, że $v$ jest prawym synem $u$.
Tuż po wypisaniu klucza $u$ wywoływane jest $\proc{Tree-Successor}(u)$.
Aby dostać się do węzła o~najmniejszym kluczu w~prawym poddrzewie węzła $u$, algorytm musi zejść krawędzią $\langle u,v\rangle$.
Przejście nią w~drodze powrotnej nastąpi po odwiedzeniu wszystkich węzłów z~prawego poddrzewa $u$, o~ile będą wówczas jeszcze nieodwiedzone węzły w~drzewie.
Będzie to miało miejsce podczas wywołania \proc{Tree-Successor} dla węzła o~maksymalnym kluczu w~prawym poddrzewie $u$, kiedy to algorytm będzie przechodził w~górę drzewa do węzła następującego po $u$ w~porządku inorder.
Krawędź $\langle u,v\rangle$ należy do tej ścieżki i~z~racji tego, że wszystkie węzły prawego poddrzewa $u$ zostały odwiedzone, nie zostanie już użyta ponownie.

\exercise %12.2-8
Jeśli węzeł początkowy $u$ nie ma prawego syna, to w~wyniku wywołania $\proc{Tree-Successor}(u)$ następnym odwiedzonym węzłem, na podstawie \refExercise{12.2-6}, będzie najniższy przodek $u$, którego lewy syn też jest przodkiem $u$.
Oznaczmy ten węzeł przez $v$.
Jeśli z~kolei prawy syn $u$ istnieje, to zanim algorytm dotrze do $v$, odwiedzi on wpierw prawe poddrzewo $u$.
O~ile nie zakończył swojego działania podczas tego kroku, to w~obu przypadkach opisane operacje zostają następnie powtórzone dla węzła $v$.
Widać zatem, że algorytm porusza się w~górę drzewa po ścieżce, której długość ograniczona jest przez wysokość drzewa, odwiedzając prawe poddrzewa węzłów z~tej ścieżki.
Ponieważ mamy $k$ wywołań \proc{Tree-Successor}, to sumaryczna liczba węzłów w~tych poddrzewach wynosi co najwyżej $O(k)$.
Algorytm działa więc w~czasie $O(k+h)$.

\exercise %12.2-9
Dowód sprowadza się do pokazania, że $y$ jest albo następnikiem albo poprzednikiem węzła $x$.

Załóżmy, że $x$ jest lewym synem węzła $y$.
Zauważmy, że w~drzewie $T$ istnieje następnik węzła $x$, ponieważ $x$ nie jest skrajnie prawym węzłem drzewa $T$.
Możemy więc skorzystać z~\refExercise{12.2-6}, żeby pokazać, że następnikiem $x$ jest w~rzeczywistości $y$.
Symetryczne twierdzenie do tego z~\refExercise{12.2-6} charakteryzujące poprzednika węzła o~pustym lewym poddrzewie, można dowieść, korzystając z~analogicznego rozumowania z~rozwiązania tamtego zadania.
W~przypadku, gdy $x$ jest prawym synem $y$, na podstawie tego twierdzenia pokazujemy, że $y$ jest poprzednikiem $x$.

\subchapter{Wstawianie i~usuwanie}

\exercise %12.3-1
Rekurencyjna wersja operacji wstawiania węzła będzie przyjmować na wejściu korzeń $x$ poddrzewa $T$, w~którym będziemy dokonywać wstawiania oraz nowy węzeł $z$.
Procedura będzie schodzić rekurencyjnie w~dół poddrzewa o~korzeniu w~$x$ odpowiednią ścieżką tak, aby na końcu tego procesu uczynić $z$ synem bieżącego węzła na tej ścieżce.
\begin{codebox}
\Procname{$\proc{Recursive-Tree-Insert}(x,z)$}
\li	\If $\attrib{z}{key}<\attrib{x}{key}$
\li		\Then
			\If $\attrib{x}{left}\ne\const{nil}$
\li				\Then $\proc{Recursive-Tree-Insert}(T,\attrib{x}{left},z)$
\li				\Else
					$\attrib{x}{left}\gets z$
\li					$\attrib{z}{p}\gets x$
				\End
\li		\Else
			\If $\attrib{x}{right}\ne\const{nil}$
\li				\Then $\proc{Recursive-Tree-Insert}(T,\attrib{x}{right},z)$
\li				\Else
					$\attrib{x}{right}\gets z$
\li					$\attrib{z}{p}\gets x$
				\End
		\End
\end{codebox}
Procedura ta wywoływana będzie przez procedurę \proc{Tree-Insert}$'$, której pseudokod znajduje się poniżej.
Testuje ona jedynie, czy drzewo $T$ jest puste i~w~zależności od wyniku umieszcza $z$ w~korzeniu drzewa $T$ albo wywołuje \proc{Recursive-Tree-Insert}.
\begin{codebox}
\Procname{$\proc{Tree-Insert$'$}(T,z)$}
\li	\If $\attrib{T}{root}=\const{nil}$
\li		\Then $\attrib{T}{root}\gets z$
\li		\Else $\proc{Recursive-Tree-Insert}(\attrib{T}{root},z)$
		\End
\end{codebox}

\exercise %12.3-2
Procedura \proc{Tree-Insert} wywołana dla nowego węzła $z$ o~kluczu $k$, będzie schodzić ścieżką od korzenia w~dół drzewa w~celu odnalezienia liścia, który stanie się ojcem węzła $z$.
Z~kolei procedura \proc{Tree-Search} wyszukująca w~drzewie węzeł o~kluczu $k$ zejdzie podobną ścieżką w~celu odnalezienia tego węzła.
Porównajmy instrukcje odpowiedzialne za poruszanie się po tych ścieżkach -- w~pierwszej procedurze są to wiersze \doubledash{3}{7}, a~w~drugiej -- wiersze \doubledash{1}{4}.
W~\proc{Tree-Insert} obecność linii 4 nie wpływa na wybór ścieżki, a~$\attrib{z}{key}=k$, więc $\attrib{x}{key}$ jest w~obu procedurach porównywane z~tą samą wartością.
Jeszcze jedną różnicą jest występowanie w~\proc{Tree-Search} dodatkowego warunku $k\ne\attrib{x}{key}$ w~pętli \kw{while}.
Z~założenia o~unikalności kluczy w~drzewie wnioskujemy, że warunek ten będzie fałszywy dla każdego węzła na ścieżce, zanim osiągnięty zostanie szukany węzeł.
Ścieżki pokonywane w~obu procedurach są zatem identyczne, przy czym procedura \proc{Tree-Search} porówna jeszcze poszukiwany klucz z~węzłem o~tym kluczu na końcu tej ścieżki.

\exercise %12.3-3
Pesymistyczny przypadek dla takiego sposobu sortowania $n$ liczb zachodzi wtedy, gdy tablica jest uporządkowana rosnąco bądź malejąco.
Wówczas drzewo powstałe po serii $n$ operacji \proc{Tree-Insert} ma wysokość $n-1$.
Budowa takiego drzewa zajmuje $O(n^2)$ i~taki też jest czas sortowania w~tym przypadku.

Z~kolei przypadek optymistyczny ma miejsce, gdy zbudowane drzewo ma minimalną wysokość.
Z~\refExercise{B.5-4} wiemy, że drzewo zawierające $n$ węzłów ma wysokość co najmniej $\lfloor\lg n\rfloor$.
Najmniejszy możliwy czas działania algorytmu sortowania wynosi zatem $O(n\lg n)$, bo to jest czas potrzebny na zbudowanie takiego drzewa.

\exercise %12.3-4
Procedura \proc{Tree-Delete} wywołana dla węzła o~dwóch synach w~rzeczywistości usunie następnik tego węzła.
Problem pojawia się, gdy pewna struktura danych przechowuje wskaźnik do węzła $y$ i~wywołane zostanie \proc{Tree-Delete} celem usunięcia węzła $z$, będącego poprzednikiem $y$.
Struktura ta może wciąż zakładać, że $z$ należy do drzewa.
Tak jednak nie jest, ponieważ to węzeł wskazywany przez $y$ został ostatecznie usunięty, a~jego wszystkie atrybuty skopiowane zostały do węzła wskazywanego przez $z$.

Rozwiązanie tego problemu polega na podmianie węzła $z$ przez $y$ tuż przed zakończeniem operacji usuwania w~przypadku, gdy węzeł $z$ początkowo miał dwóch synów.
Wówczas węzłem efektywnie usuwanym byłby za każdym razem ten wskazywany przez $z$, dlatego w~bezpiecznej wersji procedury usuwania, której pseudokod prezentujemy poniżej, możemy zrezygnować ze zwracania jakiejkolwiek wartości.
\begin{codebox}
\Procname{$\proc{Safe-Tree-Delete}(T,z)$}
\li	$y\gets\proc{Tree-Delete}(T,z)$
\li	\If $y\ne z$
\li		\Then
			$\attrib{\attrib{z}{left}}{p}\gets\attrib{\attrib{z}{right}}{p}\gets y$ \label{li:safe-tree-delete-substitute-begin}
\li			\If $\attrib{z}{p}\ne\const{nil}$
\li				\Then
					\If $z=\attrib{\attrib{z}{p}}{left}$
\li						\Then $\attrib{\attrib{z}{p}}{left}\gets y$
\li						\Else $\attrib{\attrib{z}{p}}{right}\gets y$
						\End
				\End
\li			skopiuj zawartość wszystkich pól z~$z$ do $y$ \label{li:safe-tree-delete-substitute-end}
		\End
\end{codebox}

Powyższa procedura deleguje operację usuwania węzła $z$ do oryginalnej procedury \proc{Tree-Delete}.
Jeśli zwrócony przez tę ostatnią węzeł $y$ jest różny od $z$, to w~wierszach \doubledash{\ref{li:safe-tree-delete-substitute-begin}}{\ref{li:safe-tree-delete-substitute-end}} następuje przepięcie synów i~ojca $z$ na węzeł $y$ i~przepisanie wszystkich pól z~$z$ do $y$.
Po wykonaniu tej procedury struktura danych korzystająca z~drzewa może bezpiecznie założyć, że usunięty został dokładnie ten węzeł, który stanowił argument operacji usuwania.

\exercise %12.3-5
Operacja usuwania z~drzewa wyszukiwań binarnych nie jest przemienna. Kontrprzykład został zilustrowany na rys.\ \ref{fig:12.3-5}.
\begin{figure}[ht]
	\begin{center}
		\includegraphics{fig_12.3-5}
	\end{center}
	\caption{Kontrprzykład dla przemienności operacji usuwania węzła z~drzewa BST.
{\sffamily\bfseries(a)} Przykładowe drzewo BST.
{\sffamily\bfseries(b)} Drzewo po usunięciu węzła o~kluczu 3, a~następnie węzła o~kluczu 4.
{\sffamily\bfseries(c)} Drzewo po usunięciu węzła o~kluczu 4, a~następnie węzła o~kluczu 3.} \label{fig:12.3-5}
\end{figure}

\exercise %12.3-6
Wybór między poprzednikiem i~następnikiem uzależnimy od wyniku rzutu monetą, który zasymulujemy wywołaniem $\proc{Random}(0,1)$.
Wiersz~3 w~procedurze \proc{Tree-Delete} zastąpimy więc następującym fragmentem:
\begin{codebox}
\zi	\If $\proc{Random}(0,1)=0$
\zi		\Then $y\gets\proc{Tree-Predecessor}(z)$
\zi		\Else $y\gets\proc{Tree-Successor}(z)$
\zi		\End
\end{codebox}

\subchapter{Losowo skonstruowane drzewa wyszukiwań binarnych}

\exercise %12.4-1
Wzór udowodnimy przez indukcję względem $n$.
Jeśli $n=1$, to po obu stronach znaku równości jest 1.
Załóżmy teraz, że $n>1$ i~że spełnione jest założenie indukcyjne
\[
	\sum_{i=0}^{n-2}\binom{i+3}{3} = \binom{n+2}{4}.
\]
Mamy
\[
	\sum_{i=0}^{n-1}\binom{i+3}{3} = \sum_{i=0}^{n-2}\binom{i+3}{3}+\binom{n+2}{3} = \binom{n+2}{4}+\binom{n+2}{3} = \binom{n+3}{4},
\]
przy czym w~ostatniej równości wykorzystaliśmy \refExercise{C.1-7}.

\exercise %12.4-2
Rozważmy drzewo binarne w~którym początkowe poziomy stanowią pełne drzewo binarne składające się z~$n-\sqrt{n\lg n}$ węzłów, natomiast pozostałe $\sqrt{n\lg n}$ węzłów znajduje się na ścieżce odchodzącej od tegoż pełnego drzewa w~dół na coraz to niższe poziomy.
Drzewo takie ma wysokość
\[
	\Theta\bigl(\lg\bigl(n-\sqrt{n\lg n}\bigr)\bigr)+\sqrt{n\lg n} = \Theta\bigl(\!\sqrt{n\lg n}\bigr) = \omega(\lg n).
\]

O~tym, że średnia głębokość węzła w~tym drzewie wynosi $\Theta(\lg n)$, przekonamy się, wyprowadzając najpierw górne, a~potem dolne oszacowanie tej wartości.
W~oszacowaniu górnym użyjemy $O(\lg n)$ jako ograniczenia na głębokość każdego z~$n-\sqrt{n\lg n}$ węzłów z~części stanowiącej pełne drzewo binarne oraz $O\bigl(\lg n+\sqrt{n\lg n}\bigr)$ jako ograniczenia na głębokość każdego z~$\sqrt{n\lg n}$ węzłów ze ścieżki odchodzącej od pełnego drzewa.
Średnia głębokość węzła wynosi więc co najwyżej
\[
	\frac{1}{n}\cdot O\bigl(\bigl(n-\sqrt{n\lg n}\bigr)\lg n+\sqrt{n\lg n}\,\bigl(\lg n+\sqrt{n\lg n}\bigr)\bigr) = \frac{1}{n}\cdot O(n\lg n) = O(\lg n).
\]
Z~kolei zauważmy, że najniższy poziom pełnego drzewa binarnego składa się z~$\Theta\bigl(n-\sqrt{n\lg n}\bigr)$ węzłów, z~których każdy ma głębokość $\Theta(\lg n)$.
Stąd średnia głębokość węzła ograniczona jest z~dołu przez
\[
	\frac{1}{n}\cdot\Theta\bigl(\bigl(n-\sqrt{n\lg n}\bigr)\lg n\bigr) = \frac{1}{n}\cdot\Omega(n\lg n) = \Omega(\lg n).
\]

W~drugiej części zadania udowodnimy, że wysokość drzewa binarnego o~$n$ węzłach i~średniej głębokości węzła $\Theta(\lg n)$ wynosi $O\bigl(\!\sqrt{n\lg n}\bigr)$.
Niech dane będzie drzewo binarne o~$n$ węzłach i~wysokości $h$ ze średnią głębokością węzła $\Theta(\lg n)$.
Istnieje więc ścieżka od korzenia w~dół tego drzewa, na której głębokościami węzłów są kolejno 0, 1, \dots, $h$.
Oznaczmy przez $U$ zbiór węzłów na tej ścieżce, przez $U'$ zbiór wszystkich pozostałych węzłów drzewa, a~przez $d(x)$ głębokość węzła $x$.
Wówczas średnia głębokość węzła w~tym drzewie wynosi
\[
	\frac{1}{n}\biggl(\sum_{x\in U}d(x)+\sum_{x\in U'}d(x)\biggr) \ge \frac{1}{n}\sum_{x\in U}d(x) = \frac{1}{n}\sum_{i=0}^hi = \frac{1}{n}\cdot\Theta(h^2).
\]
Jeśli byłoby $h=\omega\bigl(\!\sqrt{n\lg n}\bigr)$, to wtedy mielibyśmy
\[
	\frac{1}{n}\cdot\Theta(h^2) = \frac{1}{n}\cdot\omega(n\lg n) = \omega(\lg n),
\]
co stoi w~sprzeczności z~założeniem, że średnią głębokością węzła jest $\Theta(\lg n)$.
A~zatem wysokość drzewa musi być ograniczona przez $O\bigl(\!\sqrt{n\lg n}\bigr)$.

\exercise %12.4-3
Istnieje 5 różnych drzew BST o~$n=3$ węzłach, podczas gdy jest $3!=6$ permutacji trójelementowych.
Jest więc jasne, że któreś z~tych drzew można zbudować z~więcej niż jednej permutacji.
Rys.~\ref{fig:12.4-3} ilustruje każde drzewo, podając permutacje, z~których one powstają.
\begin{figure}[ht]
	\begin{center}
		\includegraphics{fig_12.4-3}
	\end{center}
	\caption{Drzewa BST uzyskane z~permutacji {\sffamily\bfseries(a)} $\langle1,2,3\rangle$,
{\sffamily\bfseries(b)} $\langle1,3,2\rangle$,
{\sffamily\bfseries(c)} $\langle2,1,3\rangle$ oraz $\langle2,3,1\rangle$, {\sffamily\bfseries(d)} $\langle3,1,2\rangle$, {\sffamily\bfseries(e)} $\langle3,2,1\rangle$.} \label{fig:12.4-3}
\end{figure}

\exercise %12.4-4
Udowodnimy silniejsze twierdzenie, że każda funkcja $f(x)=c^x$, gdzie $c$ jest stałą dodatnią, jest wypukła.
Z~definicji wypukłości funkcji z~dodatku C musimy pokazać, że dla każdych $x$, $y$ i~dla każdego $0\le\lambda\le1$ prawdziwa jest nierówność
\[
	c^{\lambda x+(1-\lambda)y} \le \lambda c^x+(1-\lambda)c^y.
\]

\medskip
\noindent\textsf{\textbf{Lemat.}} \textit{Dla dowolnych liczb rzeczywistych\/ $a$,\/ $b$ i~dla dowolnej dodatniej liczby rzeczywistej\/ $c$ zachodzi
\[
	c^a \ge c^b+(a-b)c^b\ln c.
\]}
\begin{proof}
Na podstawie wzoru (3.11), $e^x\ge1+x$ dla dowolnego $x$.
Jeśli przyjmiemy $x=r\ln c$, to $e^x=e^{r\ln c}=(e^{\ln c})^r=c^r$ i~nierówność sprowadza się do postaci $c^r\ge1+r\ln c$.
Po podstawieniu $r=a-b$ dostajemy $c^{a-b}\ge1+(a-b)\ln c$ i~aby otrzymać żądaną nierówność, wystarczy pomnożyć obie strony przez $c^b$.
\end{proof}

Niech $z=\lambda x+(1-\lambda)y$.
Skorzystajmy z~powyższego lematu dwukrotnie, najpierw podstawiając $a=x$ i~$b=z$ i~otrzymując nierówność $c^x\ge c^z+(x-z)c^z\ln c$, a~następnie przyjmując $a=y$ i~$b=z$, skąd dostajemy $c^y\ge c^z+(y-z)c^z\ln c$.
Pierwszą otrzymaną nierówność pomnożymy przez $\lambda$, a~drugą przez $1-\lambda$, a~następnie dodamy do siebie:
\begin{align*}
	\lambda c^x+(1-\lambda)c^y &\ge \lambda(c^z+(x-z)c^z\ln c)+(1-\lambda)(c^z+(y-z)c^z\ln c) \\
	&= \lambda c^z+\lambda xc^z\ln c-\lambda zc^z\ln c+(1-\lambda)c^z+(1-\lambda)yc^z\ln c-(1-\lambda)zc^z\ln c \\
	&= (\lambda+(1-\lambda))c^z+(\lambda x+(1-\lambda)y)c^z\ln c-(\lambda+(1-\lambda))zc^z\ln c \\
	&= c^z+zc^z\ln c-zc^z\ln c \\
	&= c^z \\
	&= c^{\lambda x+(1-\lambda)y}.
\end{align*}
Otrzymany wynik dowodzi wypukłości funkcji $f(x)=c^x$, a~więc w~szczególności $f(x)=2^x$.

\exercise %12.4-5
\note{Wymagane jest założenie, że elementy tablicy wejściowej algorytmu \proc{Randomized-Quicksort} są parami różne.}

\problems

\problem{Drzewa wyszukiwań binarnych z~powtarzającymi się kluczami} %12-1

\subproblem %12-1(a)
Pierwsze wywołanie \proc{Tree-Insert} umieszcza nowy węzeł w~korzeniu drzewa.
W~pozostałych wywołaniach warunki w~liniach 5 i~11 są fałszywe, co oznacza, że każdy nowy węzeł wstawiony zostanie jako prawy syn poprzedniego węzła i~po $n$ wywołaniach \proc{Tree-Insert} drzewo będzie mieć postać ścieżki o~$n$ elementach.
Każde kolejne wywołanie działa na drzewie o~wysokości o~1 większej niż w~poprzednim wywołaniu, więc ciąg $n$ wywołań wykona się w~czasie
\[
	T(n) = \sum_{i=1}^ni = \frac{n(n+1)}{2} = \Theta(n^2).
\]

\subproblem %12-1(b)
W~tej strategii po wstawieniu pierwszego węzła do drzewa kolejne będą umieszczane raz w~lewym, raz w~prawym poddrzewie zarówno korzenia, jak i~każdego węzła aktualnie znajdującego się w~drzewie.
Powoduje to, że podczas wstawiania węzłów drzewo jest wypełnione na każdym poziomie, być może z~wyjątkiem ostatniego.
Podczas pierwszego wywołania \proc{Tree-Insert} drzewo jest puste, a~podczas \singledash{$i$}{tego} wywołania, gdzie $i=2$, 3, \dots, $n$, jego wysokość jest równa $\lg(i-1)$.
Ciąg $n$ operacji \proc{Tree-Insert} działa zatem w~czasie
\[
	T(n) = \Theta(1)+\sum_{i=2}^n\lg(i-1) = \Theta(1)+\sum_{i=1}^{n-1}\lg i = \Theta(n\lg n)
\]
na podstawie wzoru (3.18).

\subproblem %12-1(c)
Dodanie węzła do listy węzłów o~tym samym kluczu odbywa się w~czasie stałym.
Ciąg $n$ wywołań \proc{Tree-Insert} wykona się więc w~czasie $\Theta(n)$.

\subproblem %12-1(d)
W~pesymistycznym przypadku $x$ jest za każdym razem ustawiane na \attrib{x}{left} (albo za każdym razem na \attrib{x}{right}) i~efektywność działania ciągu operacji \proc{Tree-Insert} w~tej strategii nie różni się od efektywności ciągu wywołań jej oryginalnej wersji, tworząc w~czasie $\Theta(n^2)$ drzewo będące ścieżką \singledash{$n$}{elementową}.

W~średnim przypadku każdy wstawiany węzeł może zostać liściem jakiegokolwiek aktualnego liścia w~tym drzewie.
Ciąg $n$ wywołań \proc{Tree-Insert} można więc traktować jako konstrukcję losowego drzewa binarnego z~$n$ węzłów o~różnych kluczach.
Jak wiemy z~tw.\ 12.4, oczekiwana wysokość takiego drzewa wynosi $O(\lg n)$, a~czas wymagany do jego zbudowania jest ograniczony od góry przez $O(n\lg n)$.

\problem{Drzewa pozycyjne} %12-2
\note{$S$ jest zbiorem różnych ciągów bitowych, których długości sumują się do\/ $n$.}

\noindent Zbiór $S$ ciągów bitowych możemy posortować poprzez zbudowanie z~jego elementów drzewa pozycyjnego, a~następnie wypisanie wszystkich kluczy tego drzewa należących do $S$ w~porządku preorder.
Uzasadnimy teraz to stwierdzenie i~znajdziemy czas działania tego sortowania.

Zbadajmy drzewo pozycyjne zbudowane z~elementów zbioru $S$.
Rozważmy węzeł $x$ o~kluczu $s\in S$ z~poziomu $i$ tego drzewa.
Ciąg $s$ jest \singledash{$i$}{bitowym} prefiksem wszystkich ciągów z~lewego i~z~prawego poddrzewa węzła $x$.
Ponadto w~każdym ciągu z~lewego poddrzewa na \singledash{$(i+1)$}{szej} pozycji jest 0, a~w~każdym ciągu z~prawego poddrzewa na tej samej pozycji jest 1.
A~zatem ciąg $s$ leksykograficznie poprzedza ciągi po lewej stronie $x$, które z~kolei leksykograficznie poprzedzają ciągi po prawej stronie $x$.
W~wynikowej posortowanej permutacji bezpośrednio po $s$ znajdą się więc wszystkie klucze z~$S$ należące do lewego poddrzewa węzła $x$, po czym wszystkie klucze z~$S$ należące do jego prawego poddrzewa.
Klucze w~takiej kolejności możemy wypisać, przechodząc poddrzewo o~korzeniu w~$x$ metodą preorder.
Zbiór $S$ posortujemy więc poprzez wywołanie \proc{Preorder-Tree-Walk} na całym drzewie pozycyjnym, przy czym wypisywane będą tylko klucze należące do zbioru $S$.

Wstawienie węzła o~kluczu $s$ do drzewa pozycyjnego zajmuje czas $\Theta(|s|)$, gdzie $|s|$ oznacza długość ciągu $s$, gdyż węzeł ten zostanie umieszczony na poziomie $|s|$.
Budowa drzewa pozycyjnego z~elementów zbioru $S$ odbywa się więc w~czasie
\[
	\sum_{s\in S}\Theta(|s|) = \Theta\biggl(\sum_{s\in S}|s|\biggr) = \Theta(n).
\]
Podczas wstawiania węzła o~kluczu $s$ tworzonych jest co najwyżej $|s|+1$ nowych węzłów, zatem drzewo zbudowane ze zbioru $S$ posiada nie więcej niż
\[
	\sum_{s\in S}(|s|+1) \le (|\varepsilon|+1)+\sum_{s\in S\setminus\{\varepsilon\}}2|s| = 1+2n = O(n)
\]
węzłów ($\varepsilon$ oznacza ciąg pusty).
Przechodzenie drzewa w~porządku preorder działa w~czasie proporcjonalnym do liczby jego węzłów.
Dodając do tego czas spędzony na budowaniu drzewa, otrzymujemy, że opisane sortowanie odbywa się w~czasie $\Theta(n)$.

\problem{Średnia głębokość węzła w~losowo zbudowanym drzewie wyszukiwań binarnych} %12-3

\subproblem %12-3(a)
\subproblem %12-3(b)
\subproblem %12-3(c)
\subproblem %12-3(d)
\subproblem %12-3(e)
\subproblem %12-3(f)

\problem{Zliczanie różnych drzew binarnych} %12-4

\subproblem %12-4(a)
\subproblem %12-4(b)
\subproblem %12-4(c)
\note{Definicja rozwinięcia Taylora została błędnie podana. Wyrażeniem pod znakiem sumy powinno być\/ $\frac{f^{(k)}(a)}{k!}(x-a)^k$.}

\subproblem %12-4(d)

\endinput
