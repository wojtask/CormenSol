\chapter{Drzewa wyszukiwań binarnych}

\subchapter{Co to jest drzewo wyszukiwań binarnych?}

\exercise %12.1-1
Przykładowe drzewa BST przedstawiono na rys.\ \ref{fig:12.1-1}.
\begin{figure}[ht]
	\begin{center}
		\includegraphics{fig_12.1-1}
	\end{center}
	\caption{Drzewa BST o~różnych wysokościach zawierające zbiór kluczy $\{1,4,5,10,16,17,21\}$.} \label{fig:12.1-1}
\end{figure}

\exercise %12.1-2
\note{Wyrażenie ,,właściwa kolejność'' użyte w~tłumaczeniu oznacza kolejność niemalejącą.}

\noindent Niech $x$ będzie węzłem drzewa $T$, a~$y$, $z$, odpowiednio, lewym i~prawym synem $x$.
Jeśli drzewo $T$ byłoby drzewem BST, czyli spełniałoby własność drzewa BST, to wówczas prawdziwe byłyby nierówności $\attrib{y}{key}\le\attrib{x}{key}\le\attrib{z}{key}$.
Jeśli z~kolei drzewo $T$ stanowiłoby kopiec typu min, czyli spełniałoby własność kopca typu min, to zachodziłoby wtedy $\attrib{x}{key}\le\attrib{y}{key}$ oraz $\attrib{x}{key}\le\attrib{z}{key}$.

Ta różnica sprawia, że podczas przechodzenia kopca typu min w~kolejności niemalejących węzłów, po odwiedzeniu węzła $x$ nie jest wiadomo, które jego poddrzewo należałoby następnie odwiedzić, ponieważ nie jest znana relacja między $y$ a~$z$.
Oznacza to, że wypisanie wszystkich $n$ węzłów kopca typu min w~kolejności niemalejącej zajmuje czas wyższy niż $O(n)$.
W~przeciwnym przypadku moglibyśmy zaimplementować algorytm heapsort w~czasie liniowym.

\exercise %12.1-3
Nierekurencyjna wersja algorytmu przechodzenia drzewa metodą inorder, która wykorzystuje stos, została przedstawiona w~\refExercise{10.4-3}.
Nierekurencyjny algorytm o~identycznej funkcjonalności, ale niewykorzystujący stosu, został opisany w~\refExercise{10.4-5}.

\exercise %12.1-4
Algorytmy przechodzenia drzewa metodami preorder i~postorder przedstawiono poniżej.

\begin{codebox}
\Procname{$\proc{Preorder-Tree-Walk}(x)$}
\li	\If $x\ne\const{nil}$
\li		\Then
			wypisz \attrib{x}{key}
\li			$\proc{Preorder-Tree-Walk}(\attrib{x}{left})$
\li			$\proc{Preorder-Tree-Walk}(\attrib{x}{right})$
		\End
\end{codebox}

\begin{codebox}
\Procname{$\proc{Postorder-Tree-Walk}(x)$}
\li	\If $x\ne\const{nil}$
\li		\Then
			$\proc{Postorder-Tree-Walk}(\attrib{x}{left})$
\li			$\proc{Postorder-Tree-Walk}(\attrib{x}{right})$
\li			wypisz \attrib{x}{key}
		\End
\end{codebox}

Dla każdego z~tych algorytmów można udowodnić twierdzenie analogiczne do tw.\ 12.1, a~więc każdy z~nich działa w~czasie $\Theta(n)$ na drzewie \singledash{$n$}{wierzchołkowym}.

\exercise %12.1-5
Załóżmy nie-wprost, że istnieje algorytm konstruowania drzewa BST z~dowolnej listy $n$ elementów za pomocą porównań, którego pesymistyczny czas działania wynosi $o(n\lg n)$.
Na drzewie BST utworzonym za pomocą tego algorytmu moglibyśmy następnie uruchomić algorytm przechodzenia drzewa metodą inorder i~wypisać wszystkie jego klucze w~kolejności niemalejącej w~czasie $\Theta(n)$.
Posortowanie wejściowej listy $n$ elementów można byłoby wtedy przeprowadzić w~czasie niższym niż liniowo-logarytmiczny, co przeczyłoby tw.\ 8.1.

\subchapter{Wyszukiwanie w~drzewie wyszukiwań binarnych}

\exercise %12.2-1
Ciągi z~przykładów (a), (b) i~(d) są możliwe do uzyskania podczas wyszukiwania klucza 363 w~drzewie BST.
W~przykładzie (c) po odwiedzeniu węzła o~kluczu 911 przechodzimy do lewego poddrzewa, w~którym znajdują się węzły o~kluczach nie większych niż 911.
Jednakże później napotykamy 912, a~to nie jest możliwe w~drzewie BST.
W~przykładzie (e) występuje podobna sytuacja -- po odwiedzeniu węzła o~kluczu 347 przetwarzane jest prawe poddrzewo.
Klucz 299 napotykany później jest jednak mniejszy niż 347, co w~drzewie BST nie może mieć miejsca.

\exercise %12.2-2
Rekurencyjne wersje procedur zostały przedstawione poniżej.
\begin{codebox}
\Procname{$\proc{Recursive-Tree-Minimum}(x)$}
\li	\If $\attrib{x}{left}\ne\const{nil}$
\li		\Then \Return $\proc{Recursive-Tree-Minimum}(\attrib{x}{left})$
\li		\Else \Return $x$
		\End
\end{codebox}
\begin{codebox}
\Procname{$\proc{Recursive-Tree-Maximum}(x)$}
\li	\If $\attrib{x}{right}\ne\const{nil}$
\li		\Then \Return $\proc{Recursive-Tree-Maximum}(\attrib{x}{right})$
\li		\Else \Return $x$
		\End
\end{codebox}

\exercise %12.2-3
Procedura \proc{Tree-Predecessor} jest symetryczna do \proc{Tree-Successor}.
Jej pseudokod znajduje się poniżej.
\begin{codebox}
\Procname{$\proc{Tree-Predecessor}(x)$}
\li	\If $\attrib{x}{left}\ne\const{nil}$
\li		\Then \Return $\proc{Tree-Maximum}(\attrib{x}{left})$
		\End
\li	$y\gets\attrib{x}{p}$
\li	\While $y\ne\const{nil}$ i~$x=\attrib{y}{left}$
\li		\Do
			$x\gets y$
\li			$y\gets\attrib{y}{p}$
		\End
\li	\Return $y$
\end{codebox}

\exercise %12.2-4
Rys.\ \ref{fig:12.2-4} przedstawia najmniejsze drzewo BST, które obala postawioną hipotezę.
\begin{figure}[ht]
	\begin{center}
		\includegraphics{fig_12.2-4}
	\end{center}
	\caption{Najmniejszy kontrprzykład dla rozumowania profesora Bunyana.
W~drzewie tym szukano klucza $k=4$.
Jasnym kolorem zaznaczono jedyny węzeł o~kluczu należącym do zbioru $A$, a~ciemnym kolorem -- węzły o~kluczach ze zbioru $B$.
Zbiór $C$ w~tym przykładzie jest pusty.
Klucze 1 i~2 nie spełniają nierówności postawionej w~hipotezie.} \label{fig:12.2-4}
\end{figure}

\exercise %12.2-5
Niech $x$ będzie węzłem o~dwóch synach w~drzewie BST, a~$U$ zbiorem składającym się ze wszystkich przodków $x$, których lewe poddrzewa zawierają $x$.
Węzły o~kluczach większych niż \attrib{x}{key} znajdują się w~prawym poddrzewie $x$, a~także w~zbiorze $U$ i~w~prawych poddrzewach węzłów z~$U$.
Dla każdego $u\in U$, dla każdego węzła $v$ z~prawego poddrzewa $u$ i~dla każdego węzła $w$ z~prawego poddrzewa $x$ spełnione są nierówności $\attrib{x}{key}<\attrib{w}{key}<\attrib{u}{key}<\attrib{v}{key}$, a~to oznacza, że następnik $x$ znajduje się w~jego prawym poddrzewie.

Niech $y$ będzie następnikiem węzła $x$.
Jeśli węzeł $y$ miałby lewego syna $z$, to na podstawie faktu, że $y$ należy do prawego poddrzewa $x$, zachodziłoby $\attrib{x}{key}<\attrib{z}{key}<\attrib{y}{key}$, a~to z~kolei przeczyłoby faktowi, że następnikiem $x$ jest węzeł $y$.
Stąd następnik $x$ nie ma lewego syna.

Analogiczne rozumowanie przeprowadza się dla poprzednika węzła $x$.

\exercise %12.2-6
Niech $U$ będzie zbiorem zdefiniowanym jak w~\refExercise{12.2-5}.
Na podstawie rozumowania z~tamtego zadania mamy, że dla każdego $u\in U$ i~dla każdego węzła $v$ z~prawego poddrzewa $u$ zachodzą nierówności $\attrib{x}{key}<\attrib{u}{key}<\attrib{v}{key}$.
Następnik $y$ węzła $x$ jest więc elementem zbioru $U$ o~minimalnym kluczu.

Niech $u_1$, $u_2\in U$.
Węzeł $x$ należy do lewego poddrzewa zarówno $u_1$, jak i~$u_2$.
Węzły te nie mogą znajdować się w~drzewie $T$ na tej samej głębokości, bo wtedy ich lewe poddrzewa są rozłączne.
Załóżmy więc bez utraty ogólności, że $u_2$ leży w~$T$ głębiej niż $u_1$.
Wówczas węzeł $u_2$ oraz jego lewe poddrzewo znajdują się w~lewym poddrzewie węzła $u_1$.
Wynika stąd, że im głębszy poziom węzła ze zbioru $U$, tym mniejszy jego klucz, a~to oznacza, że następnikiem węzła $x$ jest najgłębszy węzeł z~$U$, czyli najniższy przodek $x$, którego lewy syn jest także przodkiem $x$.

\exercise %12.2-7
\exercise %12.2-8
\exercise %12.2-9
Dowód sprowadza się do pokazania, że $y$ jest albo następnikiem albo poprzednikiem węzła $x$.

Załóżmy, że $x$ jest lewym synem węzła $y$.
Zauważmy, że w~drzewie $T$ istnieje następnik węzła $x$, ponieważ $x$ nie jest skrajnie prawym węzłem drzewa $T$.
Możemy więc skorzystać z~\refExercise{12.2-6}, żeby pokazać, że następnikiem $x$ jest w~rzeczywistości $y$.
Symetryczne twierdzenie do tego z~\refExercise{12.2-6} charakteryzujące poprzednika węzła o~pustym lewym poddrzewie, można dowieść, korzystając z~analogicznego rozumowania z~rozwiązania tamtego zadania.
W~przypadku, gdy $x$ jest prawym synem $y$, na podstawie tego twierdzenia pokazujemy, że $y$ jest poprzednikiem $x$.

\subchapter{Wstawianie i~usuwanie}

\exercise %12.3-1
Rekurencyjna wersja operacji wstawiania węzła będzie przyjmować na wejściu korzeń $x$ poddrzewa $T$, w~którym będziemy dokonywać wstawiania oraz nowy węzeł $z$.
Procedura będzie schodzić rekurencyjnie w~dół poddrzewa o~korzeniu w~$x$ odpowiednią ścieżką tak, aby na końcu tego procesu uczynić $z$ synem bieżącego węzła na tej ścieżce.
\begin{codebox}
\Procname{$\proc{Recursive-Tree-Insert}(x,z)$}
\li	\If $\attrib{z}{key}<\attrib{x}{key}$
\li		\Then
			\If $\attrib{x}{left}\ne\const{nil}$
\li				\Then $\proc{Recursive-Tree-Insert}(T,\attrib{x}{left},z)$
\li				\Else
					$\attrib{x}{left}\gets z$
\li					$\attrib{z}{p}\gets x$
				\End
\li		\Else
			\If $\attrib{x}{right}\ne\const{nil}$
\li				\Then $\proc{Recursive-Tree-Insert}(T,\attrib{x}{right},z)$
\li				\Else
					$\attrib{x}{right}\gets z$
\li					$\attrib{z}{p}\gets x$
				\End
		\End
\end{codebox}
Procedura ta wywoływana będzie przez procedurę \proc{Tree-Insert}$'$, której pseudokod znajduje się poniżej.
Testuje ona jedynie, czy drzewo $T$ jest puste i~w~zależności od wyniku umieszcza $z$ w~korzeniu drzewa $T$ albo wywołuje \proc{Recursive-Tree-Insert}.
\begin{codebox}
\Procname{$\proc{Tree-Insert$'$}(T,z)$}
\li	\If $\attrib{T}{root}=\const{nil}$
\li		\Then $\attrib{T}{root}\gets z$
\li		\Else $\proc{Recursive-Tree-Insert}(\attrib{T}{root},z)$
		\End
\end{codebox}

\exercise %12.3-2
\exercise %12.3-3
Pesymistyczny przypadek dla takiego sposobu sortowania $n$ liczb zachodzi wtedy, gdy tablica jest uporządkowana rosnąco bądź malejąco.
Wówczas drzewo powstałe po serii $n$ operacji \proc{Tree-Insert} ma wysokość $n-1$.
Budowa takiego drzewa zajmuje $O(n^2)$ i~taki też jest czas sortowania w~tym przypadku.

Z~kolei przypadek optymistyczny ma miejsce, gdy zbudowane drzewo ma minimalną wysokość.
Z~\refExercise{B.5-4} wiemy, że drzewo zawierające $n$ węzłów ma wysokość co najmniej $\lfloor\lg n\rfloor$.
Najmniejszy możliwy czas działania algorytmu sortowania wynosi zatem $O(n\lg n)$, bo to jest czas potrzebny na zbudowanie takiego drzewa.

\exercise %12.3-4
\exercise %12.3-5
Operacja usuwania z~drzewa wyszukiwań binarnych nie jest przemienna. Kontrprzykład został zilustrowany na rys.\ \ref{fig:12.3-5}.
\begin{figure}[ht]
	\begin{center}
		\includegraphics{fig_12.3-5}
	\end{center}
	\caption{Kontrprzykład dla przemienności operacji usuwania węzła z~drzewa BST.
{\sffamily\bfseries(a)} Przykładowe drzewo BST.
{\sffamily\bfseries(b)} Drzewo po usunięciu węzła o~kluczu 3, a~następnie węzła o~kluczu 4.
{\sffamily\bfseries(c)} Drzewo po usunięciu węzła o~kluczu 4, a~następnie węzła o~kluczu 3.} \label{fig:12.3-5}
\end{figure}

\exercise %12.3-6
Wybór między poprzednikiem i~następnikiem uzależnimy od wyniku rzutu monetą, który zasymulujemy wywołaniem $\proc{Random}(0,1)$.
Wiersz~3 w~procedurze \proc{Tree-Delete} zastąpimy więc następującym fragmentem:
\begin{codebox}
\zi	\If $\proc{Random}(0,1)=0$
\zi		\Then $y\gets\proc{Tree-Predecessor}(z)$
\zi		\Else $y\gets\proc{Tree-Successor}(z)$
\zi		\End
\end{codebox}

\subchapter{Losowo skonstruowane drzewa wyszukiwań binarnych}

\exercise %12.4-1
Wzór udowodnimy przez indukcję względem $n$.
Jeśli $n=1$, to po obu stronach znaku równości jest 1.
Załóżmy teraz, że $n>1$ i~że spełnione jest założenie indukcyjne
\[
	\sum_{i=0}^{n-2}\binom{i+3}{3} = \binom{n+2}{4}.
\]
Mamy
\[
	\sum_{i=0}^{n-1}\binom{i+3}{3} = \sum_{i=0}^{n-2}\binom{i+3}{3}+\binom{n+2}{3} = \binom{n+2}{4}+\binom{n+2}{3} = \binom{n+3}{4},
\]
przy czym w~ostatniej równości wykorzystaliśmy \refExercise{C.1-7}.

\exercise %12.4-2
\exercise %12.4-3
\exercise %12.4-4
\exercise %12.4-5
\note{Wymagane jest założenie, że elementy tablicy wejściowej algorytmu \proc{Randomized-Quicksort} są parami różne.}

\problems

\problem{Drzewa wyszukiwań binarnych z~powtarzającymi się kluczami} %12-1

\subproblem %12-1(a)
\subproblem %12-1(b)
\subproblem %12-1(c)
\subproblem %12-1(d)

\problem{Drzewa pozycyjne} %12-2

\problem{Średnia głębokość węzła w~losowo zbudowanym drzewie wyszukiwań binarnych} %12-3

\subproblem %12-3(a)
\subproblem %12-3(b)
\subproblem %12-3(c)
\subproblem %12-3(d)
\subproblem %12-3(e)
\subproblem %12-3(f)

\problem{Zliczanie różnych drzew binarnych} %12-4

\subproblem %12-4(a)
\subproblem %12-4(b)
\subproblem %12-4(c)
\subproblem %12-4(d)

\endinput
