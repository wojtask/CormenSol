\chapter{Drzewa wyszukiwań binarnych}

\subchapter{Co to jest drzewo wyszukiwań binarnych?}

\exercise %12.1-1
Przykładowe drzewa BST przedstawiono na rys.~\ref{fig:12.1-1}.
\begin{figure}[ht]
	\begin{center}
		\includegraphics{fig_12.1-1}
	\end{center}
	\caption{Drzewa BST o~różnych wysokościach zawierające zbiór kluczy $\{1,4,5,10,16,17,21\}$.} \label{fig:12.1-1}
\end{figure}

\exercise %12.1-2
\note{Wyrażenie ,,właściwa kolejność'' użyte w~tłumaczeniu oznacza kolejność niemalejącą.}

\noindent Niech $x$ będzie węzłem drzewa $T$, a~$y$, $z$, odpowiednio, lewym i~prawym synem $x$. Jeśli drzewo $T$ byłoby drzewem BST, czyli spełniałoby własność drzewa BST, to wówczas prawdziwe byłyby nierówności $\attrib{y}{key}\le\attrib{x}{key}\le\attrib{z}{key}$. Jeśli z~kolei drzewo $T$ stanowiłoby kopiec typu min, czyli spełniałoby własność kopca typu min, to zachodziłoby wtedy $\attrib{x}{key}\le\attrib{y}{key}$ oraz $\attrib{x}{key}\le\attrib{z}{key}$.

Ta różnica sprawia, że podczas przechodzenia kopca typu min w~kolejności niemalejących węzłów, po odwiedzeniu węzła $x$ nie jest wiadomo, które jego poddrzewo należałoby następnie odwiedzić, ponieważ nie jest znana relacja między $y$ a~$z$. Oznacza to, że wypisanie wszystkich $n$ węzłów kopca typu min w~kolejności niemalejącej zajmuje czas wyższy niż $O(n)$. W~przeciwnym przypadku moglibyśmy zaimplementować algorytm heapsort w~czasie liniowym.

\exercise %12.1-3
Nierekurencyjna wersja algorytmu przechodzenia drzewa metodą inorder, która wykorzystuje stos, została przedstawiona w~\refExercise{10.4-3}. Nierekurencyjny algorytm o~identycznej funkcjonalności, ale niewykorzystujący stosu, został opisany w~\refExercise{10.4-5}.

\exercise %12.1-4
Algorytmy przechodzenia drzewa metodami preorder i~postorder przedstawiono poniżej. 
\begin{codebox}
\Procname{$\proc{Preorder-Tree-Walk}(x)$}
\li	\If $x\ne\const{nil}$
\li		\Then
			wypisz \attrib{x}{key}
\li			$\proc{Preorder-Tree-Walk}(\attrib{x}{left})$
\li			$\proc{Preorder-Tree-Walk}(\attrib{x}{right})$
		\End
\end{codebox}

\begin{codebox}
\Procname{$\proc{Postorder-Tree-Walk}(x)$}
\li	\If $x\ne\const{nil}$
\li		\Then
			$\proc{Postorder-Tree-Walk}(\attrib{x}{left})$
\li			$\proc{Postorder-Tree-Walk}(\attrib{x}{right})$
\li			wypisz \attrib{x}{key}
		\End
\end{codebox}

Dla każdego z~tych algorytmów można udowodnić twierdzenie analogiczne do tw.~12.1, a~więc każdy z~nich działa w~czasie $\Theta(n)$ na drzewie \singledash{$n$}{wierzchołkowym}.

\exercise %12.1-5
Załóżmy nie-wprost, że istnieje algorytm konstruowania drzewa BST z~dowolnej listy $n$ elementów za pomocą porównań, którego pesymistyczny czas działania wynosi $o(n\lg n)$. Na drzewie BST utworzonym za pomocą tego algorytmu moglibyśmy następnie uruchomić algorytm przechodzenia drzewa metodą inorder i~wypisać wszystkie jego klucze w~kolejności niemalejącej w~czasie $\Theta(n)$. Posortowanie wejściowej listy $n$ elementów można byłoby wtedy przeprowadzić w~czasie niższym niż liniowo-logarytmiczny, co przeczyłoby tw.~8.1.

\subchapter{Wyszukiwanie w~drzewie wyszukiwań binarnych}

\exercise %12.2-1
Ciągi z~przykładów (a), (b) i~(d) są możliwe do uzyskania podczas wyszukiwania klucza 363 w~drzewie BST. W~przykładzie~(c) po odwiedzeniu węzła o~kluczu 911 przechodzimy do lewego poddrzewa, w~którym znajdują się węzły o~kluczach nie większych niż 911. Jednakże później napotykamy 912, a~to nie jest możliwe w~drzewie BST. W~przykładzie~(e) występuje podobna sytuacja -- po odwiedzeniu węzła o~kluczu 347 przetwarzane jest prawe poddrzewo. Klucz 299 napotykany później jest jednak mniejszy niż 347, co w~drzewie BST nie może mieć miejsca.

\exercise %12.2-2
Rekurencyjne wersje procedur zostały przedstawione poniżej.
\begin{codebox}
\Procname{$\proc{Recursive-Tree-Minimum}(x)$}
\li	\If $\attrib{x}{left}\ne\const{nil}$
\li		\Then \Return $\proc{Recursive-Tree-Minimum}(\attrib{x}{left})$
\li		\Else \Return $x$
		\End
\end{codebox}
\begin{codebox}
\Procname{$\proc{Recursive-Tree-Maximum}(x)$}
\li	\If $\attrib{x}{right}\ne\const{nil}$
\li		\Then \Return $\proc{Recursive-Tree-Maximum}(\attrib{x}{right})$
\li		\Else \Return $x$
		\End
\end{codebox}

\exercise %12.2-3
Procedura \proc{Tree-Predecessor} jest symetryczna do \proc{Tree-Successor}. Jej pseudokod znajduje się poniżej.
\begin{codebox}
\Procname{$\proc{Tree-Predecessor}(x)$}
\li	\If $\attrib{x}{left}\ne\const{nil}$
\li		\Then \Return $\proc{Tree-Maximum}(\attrib{x}{left})$
		\End
\li	$y\gets\attrib{x}{p}$
\li	\While $y\ne\const{nil}$ i~$x=\attrib{y}{left}$
\li		\Do
			$x\gets y$
\li			$y\gets\attrib{y}{p}$
		\End
\li	\Return $y$
\end{codebox}

\exercise %12.2-4
Rys.~\ref{fig:12.2-4} przedstawia najmniejsze drzewo BST, które obala postawioną hipotezę.
\begin{figure}[ht]
	\begin{center}
		\includegraphics{fig_12.2-4}
	\end{center}
	\caption{Najmniejszy kontrprzykład dla rozumowania profesora Bunyana. W~drzewie tym szukano klucza $k=4$. Jasnym kolorem zaznaczono jedyny węzeł o~kluczu należącym do zbioru $A$, a~ciemnym kolorem -- węzły o~kluczach ze zbioru $B$. Zbiór $C$ w~tym przykładzie jest pusty. Klucze 1 i~2 nie spełniają nierówności postawionej w~hipotezie.} \label{fig:12.2-4}
\end{figure}

\exercise %12.2-5
Niech $x$ będzie węzłem w~drzewie BST, który ma dwóch synów, a~$y$ -- najniższym przodkiem $x$, którego lewy syn jest także przodkiem $x$. Elementy o~kluczach większych niż \attrib{x}{key} znajdują się w~prawym poddrzewie $x$, a~także, jeśli $y\ne\const{nil}$, w~$y$ i~,,na prawo'' od $y$. Dla każdego węzła $z$ z~prawego poddrzewa $x$ spełniona jest nierówność $\attrib{x}{key}<\attrib{z}{key}<\attrib{y}{key}$, a~to oznacza, że następnikiem $x$ nie może być ani $y$ ani żaden węzeł na prawo od $y$.

Analogiczne rozumowanie można przeprowadzić dla poprzednika węzła $x$.

\exercise %12.2-6
\exercise %12.2-7
\exercise %12.2-8
\exercise %12.2-9
Załóżmy, że $x$ jest prawym synem węzła $y$. Pokażemy, że $y$ jest poprzednikiem $x$, czyli że \attrib{y}{key} jest największym kluczem w~drzewie $T$, mniejszym niż \attrib{x}{key}. Załóżmy jednak, że istnieje w~$T$ taki węzeł $z$, dla którego spełnione są nierówności $\attrib{y}{key}<\attrib{z}{key}<\attrib{x}{key}$. Bez utraty ogólności można przyjąć, że $z$ jest następnikiem $y$. Na mocy \refExercise{12.2-6} mamy, że $z$ jest najniższym przodkiem $y$, którego lewy syn jest także przodkiem $y$. Ale wówczas $x$ znajduje się w~lewym poddrzewie węzła $z$, a~więc zachodzi $\attrib{z}{key}>\attrib{x}{key}$, co stoi w~sprzeczności z~założeniem. Węzeł $y$ jest zatem poprzednikiem węzła $x$.

W~przypadku, gdy $x$ jest lewym synem węzła $y$, rozumując analogicznie i~korzystając z~twierdzenia symetrycznego do tego z~\refExercise{12.2-6}, można pokazać, że $y$ jest następnikiem $x$.

\subchapter{Wstawianie i~usuwanie}

\exercise %12.3-1
Rekurencyjna wersja operacji wstawiania węzła będzie przyjmować na wejściu drzewo $T$, korzeń $x$ poddrzewa $T$, w~którym będziemy dokonywać wstawiania, i~wreszcie nowy węzeł $z$. Procedura będzie schodzić rekurencyjnie w~dół poddrzewa o~korzeniu w~$x$ odpowiednią ścieżką tak, aby na końcu tego procesu uczynić $z$ synem bieżącego węzła na tej ścieżce.
\begin{codebox}
\Procname{$\proc{Recursive-Tree-Insert}(T,x,z)$}
\li	\If $x=\const{nil}$
\li		\Then
            $\attrib{T}{root}\gets z$
\li         \Return
		\End
\li	\If $\attrib{z}{key}<\attrib{x}{key}$
\li		\Then
			\If $\attrib{x}{left}\ne\const{nil}$
\li				\Then $\proc{Recursive-Tree-Insert}(T,\attrib{x}{left},z)$
\li				\Else
					$\attrib{x}{left}\gets z$
\li					$\attrib{z}{p}\gets x$
				\End
\li		\Else
			\If $\attrib{x}{right}\ne\const{nil}$
\li				\Then $\proc{Recursive-Tree-Insert}(T,\attrib{x}{right},z)$
\li				\Else
					$\attrib{x}{right}\gets z$
\li					$\attrib{z}{p}\gets x$
				\End
		\End
\end{codebox}
Aby wstawić węzeł $z$ do drzewa $T$, należy wywołać $\proc{Recursive-Tree-Insert}(T,\attrib{T}{root},z)$.

\exercise %12.3-2
\exercise %12.3-3
Pesymistyczny przypadek dla takiego sposobu sortowania $n$ liczb zachodzi wtedy, gdy tablica jest uporządkowana rosnąco bądź malejąco. Wówczas drzewo powstałe po serii $n$ operacji \proc{Tree-Insert} jest wysokości $n-1$. Budowa takiego drzewa zajmuje $O(n^2)$, a~wypisanie wszystkich węzłów nie powiększa tego wyniku i~sortowanie działa w~czasie $O(n^2)$.

Drzewo zawierające $n$ węzłów ma wysokość co najmniej $\lfloor\lg n\rfloor$ (z~\refExercise{B.5-4}). Najlepszy przypadek podczas sortowania ma zatem miejsce, kiedy drzewo ma minimalną wysokość. Jego budowa wymaga czasu $O(n\lg n)$ i~to jest najmniejszy możliwy czas działania tego algorytmu sortowania.

\exercise %12.3-4
\exercise %12.3-5
\exercise %12.3-6

\subchapter{Losowo skonstruowane drzewa wyszukiwań binarnych}

\exercise %12.4-1
Wzór udowodnimy przez indukcję względem $n$. Jeśli $n=1$, to po obu stronach znaku równości jest 1. Załóżmy teraz, że $n>1$ i~że spełnione jest założenie indukcyjne
\[
	\sum_{i=0}^{n-2}\binom{i+3}{3} = \binom{n+2}{4}.
\]
Mamy
\[
	\sum_{i=0}^{n-1}\binom{i+3}{3} = \sum_{i=0}^{n-2}\binom{i+3}{3}+\binom{n+2}{3} = \binom{n+2}{4}+\binom{n+2}{3} = \binom{n+3}{4},
\]
przy czym w~ostatniej równości wykorzystaliśmy \refExercise{C.1-7}.

\exercise %12.4-2
\exercise %12.4-3
\exercise %12.4-4
\exercise %12.4-5
\note{Wymagane jest założenie, że elementy tablicy wejściowej algorytmu \proc{Randomized-Quicksort} są parami różne.}

\problems

\problem{Drzewa wyszukiwań binarnych z~powtarzającymi się kluczami} %12-1

\subproblem %12-1(a)
\subproblem %12-1(b)
\subproblem %12-1(c)
\subproblem %12-1(d)

\problem{Drzewa pozycyjne} %12-2

\problem{Średnia głębokość węzła w~losowo zbudowanym drzewie wyszukiwań binarnych} %12-3

\subproblem %12-3(a)
\subproblem %12-3(b)
\subproblem %12-3(c)
\subproblem %12-3(d)
\subproblem %12-3(e)
\subproblem %12-3(f)

\problem{Zliczanie różnych drzew binarnych} %12-4

\subproblem %12-4(a)
\subproblem %12-4(b)
\subproblem %12-4(c)
\subproblem %12-4(d)

\endinput